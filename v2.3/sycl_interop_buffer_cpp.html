<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>oneDNN: Getting started on both CPU and GPU with SYCL extensions API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneAPI Deep Neural Network Library (oneDNN)</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneAPI Deep Neural Network Library (oneDNN)</div>
    </a>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
   <div id="projectnumber">2.3.3</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sycl_interop_buffer_cpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting started on both CPU and GPU with SYCL extensions API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>Full example text: <a class="el" href="sycl_interop_buffer_8cpp-example.html">sycl_interop_buffer.cpp</a></p>
<p>This C++ API example demonstrates programming for Intel(R) Processor Graphics with SYCL extensions API in oneDNN. The workflow includes following steps:</p><ul>
<li>Create a GPU or CPU engine. It uses DPC++ as the runtime in this sample.</li>
<li>Create a memory descriptor/object.</li>
<li>Create a SYCL kernel for data initialization.</li>
<li>Access a SYCL buffer via SYCL interoperability interface.</li>
<li>Access a SYCL queue via SYCL interoperability interface.</li>
<li>Execute a SYCL kernel with related SYCL queue and SYCL buffer</li>
<li>Create operation descriptor/operation primitives descriptor/primitive.</li>
<li>Execute the primitive with the initialized memory.</li>
<li>Validate the result through a host accessor.</li>
</ul>
<h1><a class="anchor" id="sycl_interop_buffer_cpp_headers"></a>
Public headers</h1>
<p>To start using oneDNN, we must first include the <a class="el" href="oneapi_2dnnl_2dnnl_8hpp.html">dnnl.hpp</a> header file in the application. We also include CL/sycl.hpp from DPC++ for using SYCL APIs and <a class="el" href="oneapi_2dnnl_2dnnl__debug_8h.html">dnnl_debug.h</a>, which contains some debugging facilities such as returning a string representation for common oneDNN C types. All C++ API types and functions reside in the <code>dnnl</code> namespace, and SYCL API types and functions reside in the <code>cl::sycl</code> namespace. For simplicity of the example we import both namespaces.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;example_utils.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="oneapi_2dnnl_2dnnl_8hpp.html">oneapi/dnnl/dnnl.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="oneapi_2dnnl_2dnnl__debug_8h.html">oneapi/dnnl/dnnl_debug.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;oneapi/dnnl/dnnl_sycl.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;CL/sycl.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacednnl.html">dnnl</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacecl_1_1sycl.html">cl::sycl</a>;</div></div><!-- fragment --> <h1><a class="anchor" id="sycl_interop_buffer_cpp_tutorial"></a>
sycl_interop_buffer_tutorial() function</h1>
<h2><a class="anchor" id="sycl_interop_buffer_cpp_sub1"></a>
Engine and stream</h2>
<p>All oneDNN primitives and memory objects are attached to a particular <a class="el" href="structdnnl_1_1engine.html">dnnl::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device to which they are attached, and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create engines, we must specify the <a class="el" href="structdnnl_1_1engine.html#a2635da16314dcbdb9bd9ea431316bb1a">dnnl::engine::kind</a> and the index of the device of the given kind. In this example we use the first available GPU or CPU engine, so the index for the engine is 0. This example assumes DPC++ being a runtime. In such case, during engine creation, an SYCL context is also created and attaches to the created engine.</p>
<div class="fragment"><div class="line">    <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a> eng(engine_kind, 0);</div></div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structdnnl_1_1stream.html">dnnl::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>In this example, a stream is created. This example assumes DPC++ being a runtime. During stream creation, a SYCL queue is also created and attaches to this stream.</p>
<div class="fragment"><div class="line">    <a class="code" href="structdnnl_1_1stream.html">dnnl::stream</a> strm(eng);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="sycl_interop_buffer_cpp_sub2"></a>
Wrapping data into oneDNN memory object</h2>
<p>Next, we create a memory object. We need to specify dimensions of our memory by passing a memory::dims object. Then we create a memory descriptor with these dimensions, with the <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dcea512dc597be7ae761876315165dc8bd2e" title="32-bit/single-precision floating point. ">dnnl::memory::data_type::f32</a> data type, and with the <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3faded7ac40158367123c5467281d44cbeb" title="4D CNN activations tensor; an alias for dnnl::memory::format_tag::abcd ">dnnl::memory::format_tag::nchw</a> memory format. Finally, we construct a memory object and pass the memory descriptor. The library allocates memory internally. </p><div class="fragment"><div class="line">    memory::dims tz_dims = {2, 3, 4, 5};</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> N = std::accumulate(tz_dims.begin(), tz_dims.end(), (size_t)1,</div><div class="line">            std::multiplies&lt;size_t&gt;());</div><div class="line"></div><div class="line">    memory::desc mem_d(</div><div class="line">            tz_dims, memory::data_type::f32, memory::format_tag::nchw);</div><div class="line"></div><div class="line">    memory mem = sycl_interop::make_memory(</div><div class="line">            mem_d, eng, sycl_interop::memory_kind::buffer);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="sycl_interop_buffer_cpp_sub3"></a>
Initialize the data executing a custom SYCL kernel</h2>
<p>The underlying SYCL buffer can be extracted from the memory object using the interoperability interface: <code>dnnl::sycl_interop_buffer::get_buffer&lt;T&gt;(const <a class="el" href="structdnnl_1_1memory.html" title="Memory object. ">dnnl::memory</a>)</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> sycl_buf = sycl_interop::get_buffer&lt;float&gt;(mem);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
 We are going to create an SYCL kernel that should initialize our data. To execute SYCL kernel we need a SYCL queue. For simplicity we can construct a stream and extract the SYCL queue from it. The kernel initializes the data by the <code>0, -1, 2, -3, ...</code> sequence: <code>data[i] = (-1)^i * i</code>. </p><div class="fragment"><div class="line">    queue q = sycl_interop::get_queue(strm);</div><div class="line">    q.submit([&amp;](handler &amp;cgh) {</div><div class="line">        <span class="keyword">auto</span> a = sycl_buf.get_access&lt;access::mode::write&gt;(cgh);</div><div class="line">        cgh.parallel_for&lt;kernel_tag&gt;(range&lt;1&gt;(N), [=](id&lt;1&gt; i) {</div><div class="line">            <span class="keywordtype">int</span> idx = (int)i[0];</div><div class="line">            a[idx] = (idx % 2) ? -idx : idx;</div><div class="line">        });</div><div class="line">    });</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="sycl_interop_buffer_cpp_sub4"></a>
Create and execute a primitive</h2>
<p>There are three steps to create an operation primitive in oneDNN:</p><ol type="1">
<li>Create an operation descriptor.</li>
<li>Create a primitive descriptor.</li>
<li>Create a primitive.</li>
</ol>
<p>Let's create the primitive to perform the ReLU (rectified linear unit) operation: x = max(0, x). An operation descriptor has no dependency on a specific engine - it just describes some operation. On the contrary, primitive descriptors are attached to a specific engine and represent some implementation for this engine. A primitive object is a realization of a primitive descriptor, and its construction is usually much "heavier". </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(</div><div class="line">            prop_kind::forward, algorithm::eltwise_relu, mem_d, 0.0f);</div><div class="line">    <span class="keyword">auto</span> relu_pd = eltwise_forward::primitive_desc(relu_d, eng);</div><div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd);</div></div><!-- fragment --><p><br />
<br />
<br />
 Next, execute the primitive. </p><div class="fragment"><div class="line">    relu.execute(strm, {{<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, mem}, {<a class="code" href="group__dnnl__api__primitives__common.html#ga3ca217e4a06d42a0ede3c018383c388f">DNNL_ARG_DST</a>, mem}});</div><div class="line">    strm.wait();</div></div><!-- fragment --><p><br />
<br />
</p>
<dl class="section note"><dt>Note</dt><dd>With DPC++ runtime, both CPU and GPU have asynchronous execution; However, the user can call <a class="el" href="structdnnl_1_1stream.html#a59985fa8746436057cf51a820ef8929c" title="Waits for all primitives executing in the stream to finish. ">dnnl::stream::wait()</a> to synchronize the stream and ensure that all previously submitted primitives are completed.</dd></dl>
<p><br />
</p>
<h2><a class="anchor" id="sycl_interop_buffer_cpp_sub5"></a>
Validate the results</h2>
<p>Before running validation codes, we need to access the SYCL memory on the host. The simplest way to access the SYCL-backed memory on the host is to construct a host accessor. Then we can directly read and write this data on the host. However no any conflicting operations are allowed until the host accessor is destroyed. We can run validation codes on the host accordingly. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> host_acc = sycl_buf.get_access&lt;access::mode::read&gt;();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordtype">float</span> exp_value = (i % 2) ? 0.0f : i;</div><div class="line">        <span class="keywordflow">if</span> (host_acc[i] != (<span class="keywordtype">float</span>)exp_value)</div><div class="line">            <span class="keywordflow">throw</span> std::string(</div><div class="line">                    <span class="stringliteral">&quot;Unexpected output, find a negative value after the ReLU &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;execution.&quot;</span>);</div><div class="line">    }</div></div><!-- fragment --> <h1><a class="anchor" id="sycl_interop_buffer_cpp_main"></a>
main() function</h1>
<p>We now just call everything we prepared earlier.</p>
<p>Because we are using the oneDNN C++ API, we use exceptions to handle errors (see <a class="el" href="dev_guide_c_and_cpp_apis.html">API</a>). The oneDNN C++ API throws exceptions of type <a class="el" href="structdnnl_1_1error.html">dnnl::error</a>, which contains the error status (of type <a class="el" href="group__dnnl__api__utils.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a>) and a human-readable error message accessible through the regular <code>what()</code> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">    <span class="keywordtype">int</span> exit_code = 0;</div><div class="line"></div><div class="line">    engine::kind engine_kind = parse_engine_kind(argc, argv);</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        sycl_interop_buffer_tutorial(engine_kind);</div><div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="structdnnl_1_1error.html">dnnl::error</a> &amp;e) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;oneDNN error caught: &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\tStatus: &quot;</span> &lt;&lt; dnnl_status2str(e.status) &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\tMessage: &quot;</span> &lt;&lt; e.<a class="code" href="structdnnl_1_1error.html#afcf188632b6264fba24f3300dabd9b65">what</a>() &lt;&lt; std::endl;</div><div class="line">        exit_code = 1;</div><div class="line">    } <span class="keywordflow">catch</span> (std::string &amp;e) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error in the example: &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        exit_code = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Example &quot;</span> &lt;&lt; (exit_code ? <span class="stringliteral">&quot;failed&quot;</span> : <span class="stringliteral">&quot;passed&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; on &quot;</span></div><div class="line">              &lt;&lt; engine_kind2str_upper(engine_kind) &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> exit_code;</div><div class="line">}</div></div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and running the example, the output should be just:</p>
<div class="fragment"><div class="line">Example passed.</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
    <script>
        $('#top').prependTo($('#side-nav'));
    </script>
    <div class="footer-wrapper">
        <hr>
        <ul class="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>