<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>oneDNN: Reorder between CPU and GPU engines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">oneAPI Deep Neural Network Library (oneDNN)
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Reorder between CPU and GPU engines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>This C++ API example demonstrates programming flow when reordering memory between CPU and GPU engines.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="cross_engine_reorder_8cpp-example.html">cross_engine_reorder.cpp</a> </p>
</blockquote>
<h1><a class="anchor" id="cross_engine_reorder_cpp_headers"></a>
Public headers</h1>
<p>To start using oneDNN, we must first include the <a class="el" href="dnnl_8hpp.html">dnnl.hpp</a> header file in the application. We also include <a class="el" href="dnnl__debug_8h.html">dnnl_debug.h</a>, which contains some debugging facilities such as returning a string representation for common oneDNN C types.</p>
<p>All C++ API types and functions reside in the <code>dnnl</code> namespace. For simplicity of the example we import this namespace.</p>
<h1><a class="anchor" id="cross_engine_reorder_cpp_tutorial"></a>
cross_engine_reorder_tutorial() function</h1>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub1"></a>
Engine and stream</h2>
<p>All oneDNN primitives and memory objects are attached to a particular <a class="el" href="structdnnl_1_1engine.html">dnnl::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device they are attached to, and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create engines, we must specify the <a class="el" href="structdnnl_1_1engine.html#a2635da16314dcbdb9bd9ea431316bb1a">dnnl::engine::kind</a> and the index of the device of the given kind. There is only one CPU engine and one GPU engine, so the index for both engines must be 0.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> cpu_engine = <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a>(engine::kind::cpu, 0);</div><div class="line">    <span class="keyword">auto</span> gpu_engine = <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a>(engine::kind::gpu, 0);</div></div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structdnnl_1_1stream.html">dnnl::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>In this example, a GPU stream is created.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> stream_gpu = stream(gpu_engine);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub2"></a>
Wrapping data into oneDNN GPU memory object</h2>
<p>Fill the data in CPU memory first, and then move data from CPU to GPU memory by reorder. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tz = memory::dims {2, 16, 1, 1};</div><div class="line">    <span class="keyword">auto</span> m_cpu</div><div class="line">            = memory({{tz}, memory::data_type::f32, memory::format_tag::nchw},</div><div class="line">                    cpu_engine);</div><div class="line">    <span class="keyword">auto</span> m_gpu</div><div class="line">            = memory({{tz}, memory::data_type::f32, memory::format_tag::nchw},</div><div class="line">                    gpu_engine);</div><div class="line">    fill(m_cpu, tz);</div><div class="line">    <span class="keyword">auto</span> r1 = reorder(m_cpu, m_gpu);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub3"></a>
Creating a ReLU primitive</h2>
<p>Let's now create a ReLU primitive for GPU.</p>
<p>The library implements the ReLU primitive as a particular algorithm of a more general <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitive, which applies a specified function to each element of the source tensor.</p>
<p>Just as in the case of <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a>, a user should always go through (at least) three creation steps (which, however, can sometimes be combined thanks to C++11):</p><ol type="1">
<li>Initialize an operation descriptor (in the case of this example, <a class="el" href="structdnnl_1_1eltwise__forward_1_1desc.html">dnnl::eltwise_forward::desc</a>), which defines the operation parameters including a GPU memory descriptor.</li>
<li>Create an operation primitive descriptor (here <a class="el" href="structdnnl_1_1eltwise__forward_1_1primitive__desc.html">dnnl::eltwise_forward::primitive_desc</a>) on a GPU engine, which is a <b>lightweight</b> descriptor of the actual algorithm that <b>implements</b> the given operation.</li>
<li>Create a primitive (here <a class="el" href="structdnnl_1_1eltwise__forward.html">dnnl::eltwise_forward</a>) that can be executed on GPU memory objects to compute the operation by a GPU engine.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Primitive creation might be a very expensive operation, so consider creating primitive objects once and executing them multiple times.</dd></dl>
<p>The code: </p><div class="fragment"><div class="line">    <span class="comment">//  ReLU op descriptor (uses a GPU memory as source memory.</span></div><div class="line">    <span class="comment">//  no engine- or implementation-specific information)</span></div><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(prop_kind::forward,</div><div class="line">            algorithm::eltwise_relu, m_gpu.get_desc(), 0.0f);</div><div class="line">    <span class="comment">// ReLU primitive descriptor, which corresponds to a particular</span></div><div class="line">    <span class="comment">// implementation in the library. Specify engine type for the ReLU</span></div><div class="line">    <span class="comment">// primitive. Use a GPU engine here.</span></div><div class="line">    <span class="keyword">auto</span> relu_pd = eltwise_forward::primitive_desc(relu_d, gpu_engine);</div><div class="line">    <span class="comment">// ReLU primitive</span></div><div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd);</div></div><!-- fragment --><p><br />
<br />
<br />
 </p>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub4"></a>
Getting results from a oneDNN GPU memory object</h2>
<p>After the ReLU operation, users need to get data from GPU to CPU memory by reorder. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> r2 = reorder(m_gpu, m_cpu);</div></div><!-- fragment --><p><br />
<br />
 </p>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub5"></a>
Executing all primitives</h2>
<p>Finally, let's execute all primitives and wait for their completion via the following sequence:</p>
<p>Reorder(CPU,GPU) -&gt; ReLU -&gt; Reorder(GPU,CPU).</p>
<ol type="1">
<li>After execution of the first Reorder, ReLU has source data in GPU.</li>
<li>The input and output memory objects are passed to the ReLU <code>execute()</code> method using a &lt;tag, memory&gt; map. Each tag specifies what kind of tensor each memory object represents. All <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitives require the map to have two elements: a source memory object (input) and a destination memory (output). For executing on GPU engine, both source and destination memory object must use GPU memory.</li>
<li>After the execution of the ReLU on GPU, the second Reorder moves the results from GPU to CPU.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>All primitives are executed in the SAME GPU stream (the first parameter of the <code>execute()</code> method).</dd></dl>
<p>Execution is asynchronous on GPU. This means that we need to call <a class="el" href="structdnnl_1_1stream.html#a59985fa8746436057cf51a820ef8929c">dnnl::stream::wait</a> before accessing the results.</p>
<div class="fragment"><div class="line">    <span class="comment">// wrap source data from CPU to GPU</span></div><div class="line">    r1.execute(stream_gpu, m_cpu, m_gpu);</div><div class="line">    <span class="comment">// Execute ReLU on a GPU stream</span></div><div class="line">    relu.execute(stream_gpu, {{<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, m_gpu}, {<a class="code" href="group__dnnl__api__primitives__common.html#ga3ca217e4a06d42a0ede3c018383c388f">DNNL_ARG_DST</a>, m_gpu}});</div><div class="line">    <span class="comment">// Get result data from GPU to CPU</span></div><div class="line">    r2.execute(stream_gpu, m_gpu, m_cpu);</div><div class="line"></div><div class="line">    stream_gpu.wait();</div></div><!-- fragment --><p><br />
</p>
<h2><a class="anchor" id="cross_engine_reorder_cpp_sub6"></a>
Validate the result</h2>
<p>Now that we have the computed the result on CPU memory, let's validate that it is actually correct.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (find_negative(m_cpu, tz) != 0)</div><div class="line">        <span class="keywordflow">throw</span> std::logic_error(</div><div class="line">                <span class="stringliteral">&quot;Unexpected output, find a negative value after the ReLU &quot;</span></div><div class="line">                <span class="stringliteral">&quot;execution.&quot;</span>);</div></div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and running the example, the output should be just:</p>
<div class="fragment"><div class="line">Example passed.</div></div><!-- fragment --> </div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>