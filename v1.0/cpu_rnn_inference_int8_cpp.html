<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>Intel(R) MKL-DNN: RNN int8 inference example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Intel(R) Math Kernel Library for Deep Neural Networks (Intel(R) MKL-DNN)
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RNN int8 inference example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This C++ API example demonstrates how to build GNMT model inference.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html">cpu_rnn_inference_int8.cpp</a> </p>
</blockquote>
<p>For the encoder we use:</p><ul>
<li>one primitive for the bidirectional layer of the encoder</li>
<li>one primitive for all remaining unidirectional layers in the encoder For the decoder we use:</li>
<li>one primitive for the first iteration</li>
<li>one primitive for all subsequent iterations in the decoder. Note that in this example, this primitive computes the states in place.</li>
<li>the attention mechanism is implemented separately as there is no support for the context vectors in MKL-DNN yet</li>
</ul>
<p>Initialize a CPU engine and stream. The last parameter in the call represents the index of the engine. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> cpu_engine = <a class="code" href="group__cpp__api__enums.html#gga6d88ff11a07bae09a5c348d314c5d1d9aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a>(engine::kind::cpu, 0);</div><div class="line">    stream s(cpu_engine);</div></div><!-- fragment --><p>Declare encoder net and decoder net </p><div class="fragment"><div class="line">    std::vector&lt;primitive&gt; encoder_net, decoder_net;</div><div class="line">    std::vector&lt;std::unordered_map&lt;int, memory&gt;&gt; encoder_net_args,</div><div class="line">            decoder_net_args;</div><div class="line"></div><div class="line">    std::vector&lt;float&gt; net_src(batch * src_seq_length_max * feature_size, 0.1f);</div><div class="line">    std::vector&lt;float&gt; net_dst(batch * tgt_seq_length_max * feature_size, 0.1f);</div></div><!-- fragment --><p>Quantization factors for f32 data </p><div class="fragment"><div class="line">    std::vector&lt;float&gt; weights_scales(lstm_n_gates * feature_size);</div><div class="line">    <span class="comment">// assign halves of vector with arbitrary values</span></div><div class="line">    <span class="keyword">const</span> dim_t scales_half = lstm_n_gates * feature_size / 2;</div><div class="line">    std::fill(</div><div class="line">            weights_scales.begin(), weights_scales.begin() + scales_half, 30.f);</div><div class="line">    std::fill(weights_scales.begin() + scales_half + 1, weights_scales.end(),</div><div class="line">            65.5f);</div></div><!-- fragment --><p><b>Encoder</b></p>
<p>Initialize Encoder Memory </p><div class="fragment"><div class="line">    memory::dims enc_bidir_src_layer_tz</div><div class="line">            = { src_seq_length_max, batch, feature_size };</div><div class="line">    memory::dims enc_bidir_weights_layer_tz = { enc_bidir_n_layers, 2,</div><div class="line">        feature_size, lstm_n_gates, feature_size };</div><div class="line">    memory::dims enc_bidir_weights_iter_tz = { enc_bidir_n_layers, 2,</div><div class="line">        feature_size, lstm_n_gates, feature_size };</div><div class="line">    memory::dims enc_bidir_bias_tz</div><div class="line">            = { enc_bidir_n_layers, 2, lstm_n_gates, feature_size };</div><div class="line">    memory::dims enc_bidir_dst_layer_tz</div><div class="line">            = { src_seq_length_max, batch, 2 * feature_size };</div><div class="line"></div></div><!-- fragment --><p>Encoder: 1 bidirectional layer and 7 unidirectional layers</p>
<p>Create the memory for user data </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> user_enc_bidir_src_layer_md = memory::desc({ enc_bidir_src_layer_tz },</div><div class="line">            memory::data_type::f32, memory::format_tag::tnc);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_layer_md</div><div class="line">            = memory::desc({ enc_bidir_weights_layer_tz },</div><div class="line">                    memory::data_type::f32, memory::format_tag::ldigo);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_iter_md</div><div class="line">            = memory::desc({ enc_bidir_weights_iter_tz },</div><div class="line">                    memory::data_type::f32, memory::format_tag::ldigo);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_bias_md = memory::desc({ enc_bidir_bias_tz },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldgo);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_src_layer_memory</div><div class="line">            = memory(user_enc_bidir_src_layer_md, cpu_engine, net_src.data());</div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_layer_memory = memory(user_enc_bidir_wei_layer_md,</div><div class="line">            cpu_engine, user_enc_bidir_wei_layer.data());</div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_wei_iter_memory = memory(user_enc_bidir_wei_iter_md,</div><div class="line">            cpu_engine, user_enc_bidir_wei_iter.data());</div><div class="line">    <span class="keyword">auto</span> user_enc_bidir_bias_memory = memory(</div><div class="line">            user_enc_bidir_bias_md, cpu_engine, user_enc_bidir_bias.data());</div></div><!-- fragment --><p>Create memory descriptors for RNN data w/o specified layout </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_md = memory::desc({ enc_bidir_src_layer_tz },</div><div class="line">            memory::data_type::u8, memory::format_tag::any);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> enc_bidir_wei_layer_md = memory::desc({ enc_bidir_weights_layer_tz },</div><div class="line">            memory::data_type::s8, memory::format_tag::any);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> enc_bidir_wei_iter_md = memory::desc({ enc_bidir_weights_iter_tz },</div><div class="line">            memory::data_type::s8, memory::format_tag::any);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> enc_bidir_dst_layer_md = memory::desc({ enc_bidir_dst_layer_tz },</div><div class="line">            memory::data_type::u8, memory::format_tag::any);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
Create bidirectional RNN</p>
<div class="fragment"><div class="line">    lstm_forward::desc bi_layer_desc(prop_kind::forward_inference,</div><div class="line">            rnn_direction::bidirectional_concat, enc_bidir_src_layer_md,</div><div class="line">            memory::desc(), memory::desc(), enc_bidir_wei_layer_md, enc_bidir_wei_iter_md,</div><div class="line">            user_enc_bidir_bias_md, enc_bidir_dst_layer_md, memory::desc(), memory::desc());</div></div><!-- fragment --><p>Define RNN attributes that store quantization parameters </p><div class="fragment"><div class="line">    primitive_attr attr;</div><div class="line">    attr.set_rnn_data_qparams(data_scale, data_shift);</div><div class="line">    attr.set_rnn_weights_qparams(weights_scale_mask, weights_scales);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> enc_bidir_prim_desc</div><div class="line">            = lstm_forward::primitive_desc(bi_layer_desc, attr, cpu_engine);</div></div><!-- fragment --><p>Create memory for input data and use reorders to quantize values to int8 NOTE: same attributes are used when creating RNN primitive and reorders </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_memory</div><div class="line">            = memory(enc_bidir_prim_desc.src_layer_desc(), cpu_engine);</div><div class="line">    <span class="keyword">auto</span> enc_bidir_src_layer_reorder_pd = reorder::primitive_desc(</div><div class="line">            user_enc_bidir_src_layer_memory, enc_bidir_src_layer_memory, attr);</div><div class="line">    encoder_net.push_back(reorder(enc_bidir_src_layer_reorder_pd));</div><div class="line">    encoder_net_args.push_back(</div><div class="line">            { { MKLDNN_ARG_FROM, user_enc_bidir_src_layer_memory },</div><div class="line">                    { MKLDNN_ARG_TO, enc_bidir_src_layer_memory } });</div></div><!-- fragment --><p>Encoder : add the bidirectional rnn primitive with related arguments into encoder_net </p><div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_bidir_prim_desc));</div><div class="line">    encoder_net_args.push_back(</div><div class="line">            { { MKLDNN_ARG_SRC_LAYER, enc_bidir_src_layer_memory },</div><div class="line">                    { MKLDNN_ARG_WEIGHTS_LAYER, enc_bidir_wei_layer_memory },</div><div class="line">                    { MKLDNN_ARG_WEIGHTS_ITER, enc_bidir_wei_iter_memory },</div><div class="line">                    { MKLDNN_ARG_BIAS, user_enc_bidir_bias_memory },</div><div class="line">                    { MKLDNN_ARG_DST_LAYER, enc_bidir_dst_layer_memory } });</div></div><!-- fragment --><p>Encoder: unidirectional layers</p>
<p>First unidirectinal layer scales 2 * feature_size output of bidirectional layer to feature_size output </p><div class="fragment"><div class="line">    std::vector&lt;float&gt; user_enc_uni_first_wei_layer(</div><div class="line">            1 * 1 * 2 * feature_size * lstm_n_gates * feature_size, 0.3f);</div><div class="line">    std::vector&lt;float&gt; user_enc_uni_first_wei_iter(</div><div class="line">            1 * 1 * feature_size * lstm_n_gates * feature_size, 0.2f);</div><div class="line">    std::vector&lt;float&gt; user_enc_uni_first_bias(</div><div class="line">            1 * 1 * lstm_n_gates * feature_size, 1.0f);</div></div><!-- fragment --><p>Encoder : Create unidirection RNN for first cell </p><div class="fragment"><div class="line"></div><div class="line">    lstm_forward::desc enc_uni_first_layer_desc(prop_kind::forward_inference,</div><div class="line">            rnn_direction::unidirectional_left2right,</div><div class="line">            enc_bidir_dst_layer_md, memory::desc(), memory::desc(), enc_uni_first_wei_layer_md,</div><div class="line">            enc_uni_first_wei_iter_md, user_enc_uni_first_bias_md,</div><div class="line">            enc_uni_first_dst_layer_md, memory::desc(), memory::desc());</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> enc_uni_first_prim_desc = lstm_forward::primitive_desc(</div><div class="line">            enc_uni_first_layer_desc, attr, cpu_engine);</div></div><!-- fragment --><p>Encoder : add the first unidirectional rnn primitive with related arguments into encoder_net </p><div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_uni_first_prim_desc));</div><div class="line">    encoder_net_args.push_back({</div><div class="line">            { MKLDNN_ARG_SRC_LAYER, enc_bidir_dst_layer_memory },</div><div class="line">            { MKLDNN_ARG_WEIGHTS_LAYER, enc_uni_first_wei_layer_memory },</div><div class="line">            { MKLDNN_ARG_WEIGHTS_ITER, enc_uni_first_wei_iter_memory },</div><div class="line">            { MKLDNN_ARG_BIAS, user_enc_uni_first_bias_memory },</div><div class="line">            { MKLDNN_ARG_DST_LAYER, enc_uni_first_dst_layer_memory } });</div></div><!-- fragment --><p>Encoder : Remaining unidirectional layers </p><div class="fragment"><div class="line">    std::vector&lt;float&gt; user_enc_uni_wei_layer((enc_unidir_n_layers - 1) * 1</div><div class="line">                    * feature_size * lstm_n_gates * feature_size,</div><div class="line">            0.3f);</div><div class="line">    std::vector&lt;float&gt; user_enc_uni_wei_iter((enc_unidir_n_layers - 1) * 1</div><div class="line">                    * feature_size * lstm_n_gates * feature_size,</div><div class="line">            0.2f);</div><div class="line">    std::vector&lt;float&gt; user_enc_uni_bias(</div><div class="line">            (enc_unidir_n_layers - 1) * 1 * lstm_n_gates * feature_size, 1.0f);</div></div><!-- fragment --><p>Encoder : Create unidirection RNN cell </p><div class="fragment"><div class="line"></div><div class="line">    lstm_forward::desc enc_uni_layer_desc(prop_kind::forward_inference,</div><div class="line">            rnn_direction::unidirectional_left2right,</div><div class="line">            enc_uni_first_dst_layer_md, memory::desc(), memory::desc(), enc_uni_wei_layer_md,</div><div class="line">            enc_uni_wei_iter_md, user_enc_uni_bias_md, enc_dst_layer_md,</div><div class="line">            memory::desc(), memory::desc());</div><div class="line">    <span class="keyword">auto</span> enc_uni_prim_desc</div><div class="line">            = lstm_forward::primitive_desc(enc_uni_layer_desc, attr, cpu_engine);</div></div><!-- fragment --><p>Encoder : add the unidirectional rnn primitive with related arguments into encoder_net </p><div class="fragment"><div class="line">    encoder_net.push_back(lstm_forward(enc_uni_prim_desc));</div><div class="line">    encoder_net_args.push_back({</div><div class="line">            { MKLDNN_ARG_SRC_LAYER, enc_uni_first_dst_layer_memory },</div><div class="line">            { MKLDNN_ARG_WEIGHTS_LAYER, enc_uni_wei_layer_memory },</div><div class="line">            { MKLDNN_ARG_WEIGHTS_ITER, enc_uni_wei_iter_memory },</div><div class="line">            { MKLDNN_ARG_BIAS, user_enc_uni_bias_memory },</div><div class="line">            { MKLDNN_ARG_DST_LAYER, enc_dst_layer_memory } });</div></div><!-- fragment --><p><b>Decoder with attention mechanism</b></p>
<p>Decoder : declare memory dimensions </p><div class="fragment"><div class="line">    std::vector&lt;float&gt; user_dec_wei_layer(</div><div class="line">            dec_n_layers * 1 * feature_size * lstm_n_gates * feature_size,</div><div class="line">            0.2f);</div><div class="line">    std::vector&lt;float&gt; user_dec_wei_iter(dec_n_layers * 1</div><div class="line">                    * (feature_size + feature_size) * lstm_n_gates</div><div class="line">                    * feature_size,</div><div class="line">            0.3f);</div><div class="line">    std::vector&lt;float&gt; user_dec_bias(</div><div class="line">            dec_n_layers * 1 * lstm_n_gates * feature_size, 1.0f);</div><div class="line">    std::vector&lt;int8_t&gt; user_weights_attention_src_layer(</div><div class="line">            feature_size * feature_size, 1);</div><div class="line">    <span class="keywordtype">float</span> weights_attention_scale = 127.;</div><div class="line">    std::vector&lt;float&gt; user_weights_annotation(</div><div class="line">            feature_size * feature_size, 1.0f);</div><div class="line">    std::vector&lt;float&gt; user_weights_alignments(feature_size, 1.0f);</div><div class="line">    <span class="comment">// Buffer to store decoder output for all iterations</span></div><div class="line">    std::vector&lt;uint8_t&gt; dec_dst(tgt_seq_length_max * batch * feature_size, 0);</div><div class="line"></div><div class="line">    memory::dims user_dec_wei_layer_dims</div><div class="line">            = { dec_n_layers, 1, feature_size, lstm_n_gates, feature_size };</div><div class="line">    memory::dims user_dec_wei_iter_dims = { dec_n_layers, 1,</div><div class="line">        feature_size + feature_size, lstm_n_gates, feature_size };</div><div class="line">    memory::dims user_dec_bias_dims</div><div class="line">            = { dec_n_layers, 1, lstm_n_gates, feature_size };</div><div class="line">    memory::dims dec_src_layer_dims = { 1, batch, feature_size };</div><div class="line">    memory::dims dec_dst_layer_dims = { 1, batch, feature_size };</div><div class="line">    memory::dims dec_dst_iter_c_dims = { dec_n_layers, 1, batch,</div><div class="line">        feature_size };</div></div><!-- fragment --><div class="fragment"><div class="line">    memory::dims dec_dst_iter_dims = { dec_n_layers, 1, batch,</div><div class="line">        feature_size + feature_size };</div><div class="line">    memory::dims dec_dst_iter_noctx_dims</div><div class="line">            = { dec_n_layers, 1, batch, feature_size };</div></div><!-- fragment --><p>Decoder : create memory description Create memory descriptors for RNN data w/o specified layout </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> user_dec_wei_layer_md = memory::desc({ user_dec_wei_layer_dims },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldigo);</div><div class="line">    <span class="keyword">auto</span> user_dec_wei_iter_md = memory::desc({ user_dec_wei_iter_dims },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldigo);</div><div class="line">    <span class="keyword">auto</span> user_dec_bias_md = memory::desc({ user_dec_bias_dims },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldgo);</div><div class="line">    <span class="keyword">auto</span> dec_src_layer_md = memory::desc({ dec_src_layer_dims },</div><div class="line">            memory::data_type::u8, memory::format_tag::tnc);</div><div class="line">    <span class="keyword">auto</span> dec_dst_layer_md = memory::desc({ dec_dst_layer_dims },</div><div class="line">            memory::data_type::u8, memory::format_tag::tnc);</div><div class="line">    <span class="keyword">auto</span> dec_dst_iter_md = memory::desc({ dec_dst_iter_dims },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldnc);</div><div class="line">    <span class="keyword">auto</span> dec_dst_iter_c_md = memory::desc({ dec_dst_iter_c_dims },</div><div class="line">            memory::data_type::f32, memory::format_tag::ldnc);</div></div><!-- fragment --><p>Decoder : Create memory </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> user_dec_wei_layer_memory = memory(</div><div class="line">            user_dec_wei_layer_md, cpu_engine, user_dec_wei_layer.data());</div><div class="line">    <span class="keyword">auto</span> user_dec_wei_iter_memory = memory(</div><div class="line">            user_dec_wei_iter_md, cpu_engine, user_dec_wei_iter.data());</div><div class="line">    <span class="keyword">auto</span> user_dec_bias_memory</div><div class="line">            = memory(user_dec_bias_md, cpu_engine, user_dec_bias.data());</div><div class="line">    <span class="keyword">auto</span> dec_src_layer_memory = memory(dec_src_layer_md, cpu_engine);</div><div class="line">    <span class="keyword">auto</span> dec_dst_layer_memory</div><div class="line">            = memory(dec_dst_layer_md, cpu_engine, dec_dst.data());</div><div class="line">    <span class="keyword">auto</span> dec_dst_iter_c_memory = memory(dec_dst_iter_c_md, cpu_engine);</div></div><!-- fragment --><p>Decoder : As mentioned above, we create a view without context out of the memory with context. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> dec_dst_iter_memory = memory(dec_dst_iter_md, cpu_engine);</div><div class="line">    <span class="keyword">auto</span> dec_dst_iter_noctx_md = dec_dst_iter_md.submemory_desc(</div><div class="line">            dec_dst_iter_noctx_dims, { 0, 0, 0, 0, 0 });</div></div><!-- fragment --><p>Decoder : Create memory for input data and use reorders to quantize values to int8 </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> dec_wei_layer_memory</div><div class="line">            = memory(dec_ctx_prim_desc.weights_layer_desc(), cpu_engine);</div><div class="line">    <span class="keyword">auto</span> dec_wei_layer_reorder_pd = reorder::primitive_desc(</div><div class="line">            user_dec_wei_layer_memory, dec_wei_layer_memory, attr);</div><div class="line">    reorder(dec_wei_layer_reorder_pd)</div><div class="line">            .execute(s, user_dec_wei_layer_memory, dec_wei_layer_memory);</div></div><!-- fragment --><p><b>Execution</b></p>
<p>run encoder (1 stream) </p><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; encoder_net.size(); ++p)</div><div class="line">            encoder_net.at(p).execute(s, encoder_net_args.at(p));</div></div><!-- fragment --><p>we compute the weighted annotations once before the decoder </p><div class="fragment"><div class="line">        compute_weighted_annotations(weighted_annotations.data(),</div><div class="line">                src_seq_length_max, batch, feature_size,</div><div class="line">                user_weights_annotation.data(),</div><div class="line">                (<span class="keywordtype">float</span> *)enc_dst_layer_memory.get_data_handle());</div></div><!-- fragment --><p>precompute compensation for s8u8s32 gemm in compute attention </p><div class="fragment"><div class="line">        compute_sum_of_rows(user_weights_attention_src_layer.data(),</div><div class="line">                feature_size, feature_size, weights_attention_sum_rows.data());</div></div><!-- fragment --><p>We initialize src_layer to the embedding of the end of sequence character, which are assumed to be 0 here </p><div class="fragment"><div class="line">        memset(dec_src_layer_memory.get_data_handle(), 0,</div><div class="line">                dec_src_layer_memory.get_desc().get_size());</div></div><!-- fragment --><p>From now on, src points to the output of the last iteration</p>
<p>Compute attention context vector into the first layer src_iter </p><div class="fragment"><div class="line">            compute_attention(src_att_iter_handle, src_seq_length_max, batch,</div><div class="line">                    feature_size, user_weights_attention_src_layer.data(),</div><div class="line">                    weights_attention_scale, weights_attention_sum_rows.data(),</div><div class="line">                    src_att_layer_handle, data_scale, data_shift,</div><div class="line">                    (uint8_t *)enc_bidir_dst_layer_memory.get_data_handle(),</div><div class="line">                    weighted_annotations.data(),</div><div class="line">                    user_weights_alignments.data());</div></div><!-- fragment --><p>copy the context vectors to all layers of src_iter </p><div class="fragment"><div class="line">            copy_context(src_att_iter_handle, dec_n_layers, batch,</div><div class="line">                    feature_size);</div></div><!-- fragment --><p>run the decoder iteration </p><div class="fragment"><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; decoder_net.size(); ++p)</div><div class="line">                decoder_net.at(p).execute(s, decoder_net_args.at(p));</div></div><!-- fragment --><p>Move the handle on the src/dst layer to the next iteration </p><div class="fragment"><div class="line">            <span class="keyword">auto</span> dst_layer_handle</div><div class="line">                    = (uint8_t *)dec_dst_layer_memory.get_data_handle();</div><div class="line">            dec_src_layer_memory.set_data_handle(dst_layer_handle);</div><div class="line">            dec_dst_layer_memory.set_data_handle(</div><div class="line">                    dst_layer_handle + batch * feature_size);</div></div><!-- fragment --></div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>