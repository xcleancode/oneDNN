<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>Intel(R) MKL-DNN: Getting started on GPU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Intel(R) Math Kernel Library for Deep Neural Networks (Intel(R) MKL-DNN)
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting started on GPU </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>This C++ API example demonstrates programming for Intel(R) Processor Graphics with Intel(R) MKL-DNN.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="gpu_getting_started_8cpp-example.html">gpu_getting_started.cpp</a> </p>
</blockquote>
<ul>
<li>How to create Intel MKL-DNN memory objects for both GPU and CPU.</li>
<li>How to get data from the user's buffer into an Intel MKL-DNN GPU memory object.</li>
<li>How to get results from an Intel MKL-DNN GPU memory object into the user's buffer.</li>
<li>How to create Intel MKL-DNN primitives on GPU.</li>
<li>How to execute the primitives on GPU.</li>
</ul>
<h1><a class="anchor" id="gpu_getting_started_cpp_headers"></a>
Public headers</h1>
<p>To start using Intel MKL-DNN, we must first include the <a class="el" href="mkldnn_8hpp.html">mkldnn.hpp</a> header file in the application. We also include <a class="el" href="mkldnn__debug_8h.html">mkldnn_debug.h</a>, which contains some debugging facilities such as returning a string representation for common Intel MKL-DNN C types.</p>
<p>All C++ API types and functions reside in the <code>mkldnn</code> namespace. For simplicity of the example we import this namespace.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mkldnn_8hpp.html">mkldnn.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// Optional header to access debug functions like `mkldnn_status2str()`</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mkldnn__debug_8h.html">mkldnn_debug.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacemkldnn.html">mkldnn</a>;</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div></div><!-- fragment --> <h1><a class="anchor" id="gpu_getting_started_cpp_tutorial"></a>
gpu_getting_started_tutorial() function</h1>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub1"></a>
Engine and stream</h2>
<p>All Intel MKL-DNN primitives and memory objects are attached to a particular <a class="el" href="structmkldnn_1_1engine.html">mkldnn::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device they are attached to, and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create engines, we must specify the <a class="el" href="structmkldnn_1_1engine.html#a81bcf1ea92d7f98852a2c3e187825de6">mkldnn::engine::kind</a> and the index of the device of the given kind. There is only one CPU engine and one GPU engine, so the index for both engines must be 0.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> cpu_engine = <a class="code" href="group__cpp__api__enums.html#gga6d88ff11a07bae09a5c348d314c5d1d9aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a>(engine::kind::cpu, 0);</div><div class="line">    <span class="keyword">auto</span> gpu_engine = <a class="code" href="group__cpp__api__enums.html#gga6d88ff11a07bae09a5c348d314c5d1d9aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a>(engine::kind::gpu, 0);</div></div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structmkldnn_1_1stream.html">mkldnn::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>In this example, a GPU stream is created.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> stream_gpu = stream(gpu_engine);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub2"></a>
Wrapping data into Intel MKL-DNN GPU memory object</h2>
<p>Fill the data in CPU memory first, and then move data from CPU to GPU memory by reorder. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tz = memory::dims{ 2, 16, 1, 1 };</div><div class="line">    <span class="keyword">auto</span> m_cpu = memory(</div><div class="line">            { { tz }, memory::data_type::f32, memory::format_tag::nchw },</div><div class="line">            cpu_engine);</div><div class="line">    <span class="keyword">auto</span> m_gpu = memory(</div><div class="line">            { { tz }, memory::data_type::f32, memory::format_tag::nchw },</div><div class="line">            gpu_engine);</div><div class="line">    fill(m_cpu, tz);</div><div class="line">    <span class="keyword">auto</span> r1 = reorder(m_cpu, m_gpu);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub3"></a>
Creating a ReLU primitive</h2>
<p>Let's now create a ReLU primitive for GPU.</p>
<p>The library implements the ReLU primitive as a particular algorithm of a more general <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitive, which applies a specified function to each element of the source tensor.</p>
<p>Just as in the case of <a class="el" href="structmkldnn_1_1memory.html">mkldnn::memory</a>, a user should always go through (at least) three creation steps (which, however, can sometimes be combined thanks to C++11):</p><ol type="1">
<li>Initialize an operation descriptor (in the case of this example, <a class="el" href="structmkldnn_1_1eltwise__forward_1_1desc.html">mkldnn::eltwise_forward::desc</a>), which defines the operation parameters including a GPU memory descriptor.</li>
<li>Create an operation primitive descriptor (here <a class="el" href="structmkldnn_1_1eltwise__forward_1_1primitive__desc.html">mkldnn::eltwise_forward::primitive_desc</a>) on a GPU engine, which is a <b>lightweight</b> descriptor of the actual algorithm that <b>implements</b> the given operation.</li>
<li>Create a primitive (here <a class="el" href="structmkldnn_1_1eltwise__forward.html">mkldnn::eltwise_forward</a>) that can be executed on GPU memory objects to compute the operation by a GPU engine.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Primitive creation might be a very expensive operation, so consider creating primitive objects once and executing them multiple times.</dd></dl>
<p>The code: </p><div class="fragment"><div class="line">    <span class="comment">//  ReLU op descriptor (uses a GPU memory as source memory.</span></div><div class="line">    <span class="comment">//  no engine- or implementation-specific information)</span></div><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(prop_kind::forward,</div><div class="line">            algorithm::eltwise_relu, m_gpu.get_desc(), 0.0f);</div><div class="line">    <span class="comment">// ReLU primitive descriptor, which corresponds to a particular</span></div><div class="line">    <span class="comment">// implementation in the library. Specify engine type for the ReLU</span></div><div class="line">    <span class="comment">// primitive. Use a GPU engine here.</span></div><div class="line">    <span class="keyword">auto</span> relu_pd = eltwise_forward::primitive_desc(relu_d, gpu_engine);</div><div class="line">    <span class="comment">// ReLU primitive</span></div><div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd);</div></div><!-- fragment --><p><br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub4"></a>
Getting results from an Intel MKL-DNN GPU memory object</h2>
<p>After the ReLU operation, users need to get data from GPU to CPU memory by reorder. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> r2 = reorder(m_gpu, m_cpu);</div></div><!-- fragment --><p><br />
<br />
 </p>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub5"></a>
Executing all primitives</h2>
<p>Finally, let's execute all primitives and wait for their completion via the following sequence:</p>
<p>Reorder(CPU,GPU) -&gt; ReLU -&gt; Reorder(GPU,CPU).</p>
<ol type="1">
<li>After execution of the first Reorder, ReLU has source data in GPU.</li>
<li>The input and output memory objects are passed to the ReLU <code>execute()</code> method using a &lt;tag, memory&gt; map. Each tag specifies what kind of tensor each memory object represents. All <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitives require the map to have two elements: a source memory object (input) and a destination memory (output). For executing on GPU engine, both source and destination memory object must use GPU memory.</li>
<li>After the execution of the ReLU on GPU, the second Reorder moves the results from GPU to CPU.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>All primitives are executed in the SAME GPU stream (the first parameter of the <code>execute()</code> method).</dd></dl>
<p>Depending on the stream kind, an execution might be blocking or non-blocking. This means that we need to call <a class="el" href="structmkldnn_1_1stream.html#a48181ce0f5eb3bcd75778b5aa8866df6">mkldnn::stream::wait</a> before accessing the results.</p>
<div class="fragment"><div class="line">    <span class="comment">// wrap source data from CPU to GPU</span></div><div class="line">    r1.execute(stream_gpu, m_cpu, m_gpu);</div><div class="line">    <span class="comment">// Execute ReLU on a GPU stream</span></div><div class="line">    relu.execute(stream_gpu,</div><div class="line">            { { MKLDNN_ARG_SRC, m_gpu }, { MKLDNN_ARG_DST, m_gpu } });</div><div class="line">    <span class="comment">// Get result data from GPU to CPU</span></div><div class="line">    r2.execute(stream_gpu, m_gpu, m_cpu);</div><div class="line"></div><div class="line">    stream_gpu.wait();</div></div><!-- fragment --><p><br />
</p>
<h2><a class="anchor" id="gpu_getting_started_cpp_sub6"></a>
Validate the result</h2>
<p>Now that we have the computed the result on CPU memory, let's validate that it is actually correct.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (find_negative(m_cpu, tz) != 0) {</div><div class="line">        std::stringstream ss;</div><div class="line">        ss &lt;&lt; <span class="stringliteral">&quot;Unexpected output, find a negative value after the ReLU execution&quot;</span>;</div><div class="line">        <span class="keywordflow">throw</span> ss.str();</div><div class="line">    }</div></div><!-- fragment --> <h1><a class="anchor" id="gpu_getting_started_cpp_main"></a>
main() function</h1>
<p>We now just call everything we prepared earlier.</p>
<p>Since we are using the Intel MKL-DNN C++ API, we use exceptions to handle errors (see <a class="el" href="dev_guide_c_and_cpp_apis.html">C and C++ APIs</a>). The Intel MKL-DNN C++ API throws exceptions of type <a class="el" href="structmkldnn_1_1error.html">mkldnn::error</a>, which contains the error status (of type <a class="el" href="group__c__api__types__generic.html#ga31866789b66acfb1c28b2f9bdd7bdfdd">mkldnn_status_t</a>) and a human-readable error message accessible through regular <code>what()</code> method. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        gpu_getting_started_tutorial();</div><div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="structmkldnn_1_1error.html">mkldnn::error</a> &amp;e) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Intel MKL-DNN error: &quot;</span> &lt;&lt; e.<a class="code" href="structmkldnn_1_1error.html#ac454d6c74b6c5bf2bae982d506b98f64">what</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Error status: &quot;</span> &lt;&lt; mkldnn_status2str(e.status) &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    } <span class="keywordflow">catch</span> (std::string &amp;e) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error in the example: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Example passes&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and running the example, the output should be just:</p>
<div class="fragment"><div class="line">Example passes</div></div><!-- fragment --> </div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>