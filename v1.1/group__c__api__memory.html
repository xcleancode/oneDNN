<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>DNNL: Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Deep Neural Network Library (DNNL)
   &#160;<span id="projectnumber">1.1.3</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory<div class="ingroups"><a class="el" href="group__c__api.html">C API</a> &raquo; <a class="el" href="group__c__api__primitive.html">Primitive operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A primitive to describe and store data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga77c4ac2c6c59730ade594b954c145f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga77c4ac2c6c59730ade594b954c145f73">dnnl_memory_desc_init_by_strides</a> (<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *memory_desc, int ndims, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims, <a class="el" href="group__c__api__types__generic.html#ga012ba1c84ff24bdd068f9d2f9b26a130">dnnl_data_type_t</a> data_type, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> strides)</td></tr>
<tr class="memdesc:ga77c4ac2c6c59730ade594b954c145f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>memory_desc</code> memory descriptor using <code>ndims</code>, <code>dims</code>, <code>data_type</code>, and <code>strides</code>.  <a href="#ga77c4ac2c6c59730ade594b954c145f73">More...</a><br /></td></tr>
<tr class="separator:ga77c4ac2c6c59730ade594b954c145f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff696e368aeefb3036a0419c508dc6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gaff696e368aeefb3036a0419c508dc6be">dnnl_memory_desc_init_by_tag</a> (<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *memory_desc, int ndims, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims, <a class="el" href="group__c__api__types__generic.html#ga012ba1c84ff24bdd068f9d2f9b26a130">dnnl_data_type_t</a> data_type, <a class="el" href="group__c__api__types__generic.html#ga395e42b594683adb25ed2d842bb3091d">dnnl_format_tag_t</a> tag)</td></tr>
<tr class="memdesc:gaff696e368aeefb3036a0419c508dc6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>memory_desc</code> memory descriptor using <code>ndims</code>, <code>dims</code>, <code>data_type</code>, and format <code>tag</code>.  <a href="#gaff696e368aeefb3036a0419c508dc6be">More...</a><br /></td></tr>
<tr class="separator:gaff696e368aeefb3036a0419c508dc6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b56f5755bb767c60b4f1b3dfc34445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga21b56f5755bb767c60b4f1b3dfc34445">dnnl_memory_desc_init_submemory</a> (<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *memory_desc, const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *parent_memory_desc, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> offsets)</td></tr>
<tr class="memdesc:ga21b56f5755bb767c60b4f1b3dfc34445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code>memory_desc</code> for a given <code>parent_memory_desc</code>, with <code>dims</code> sizes and <code>offsets</code>.  <a href="#ga21b56f5755bb767c60b4f1b3dfc34445">More...</a><br /></td></tr>
<tr class="separator:ga21b56f5755bb767c60b4f1b3dfc34445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5994f41ff7305a203aacce192d4eac35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga5994f41ff7305a203aacce192d4eac35">dnnl_memory_desc_reshape</a> (<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *out_memory_desc, const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *in_memory_desc, int ndims, const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a> dims)</td></tr>
<tr class="memdesc:ga5994f41ff7305a203aacce192d4eac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>out_memory_desc</code> with new <code>ndims</code> and <code>dims</code> from a <code>in_memory_desc</code>.  <a href="#ga5994f41ff7305a203aacce192d4eac35">More...</a><br /></td></tr>
<tr class="separator:ga5994f41ff7305a203aacce192d4eac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa734e01591b567ed6378df1f404058e2"><td class="memItemLeft" align="right" valign="top">int DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gaa734e01591b567ed6378df1f404058e2">dnnl_memory_desc_equal</a> (const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *lhs, const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *rhs)</td></tr>
<tr class="memdesc:gaa734e01591b567ed6378df1f404058e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory descriptors.  <a href="#gaa734e01591b567ed6378df1f404058e2">More...</a><br /></td></tr>
<tr class="separator:gaa734e01591b567ed6378df1f404058e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed039afa75d9f56763e2c1321f1563c4"><td class="memItemLeft" align="right" valign="top"><a id="gaed039afa75d9f56763e2c1321f1563c4"></a>
size_t DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gaed039afa75d9f56763e2c1321f1563c4">dnnl_memory_desc_get_size</a> (const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *memory_desc)</td></tr>
<tr class="memdesc:gaed039afa75d9f56763e2c1321f1563c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (in bytes) that is required for given <code>memory_desc</code>. <br /></td></tr>
<tr class="separator:gaed039afa75d9f56763e2c1321f1563c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a9246bd7f4e498b08d61e75e689a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga52a9246bd7f4e498b08d61e75e689a0c">dnnl_memory_create</a> (<a class="el" href="group__c__api__types__memory.html#ga2b79954bd7bb293e766a89189e8440fd">dnnl_memory_t</a> *memory, const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *memory_desc, <a class="el" href="group__c__api__engine__types.html#ga1ce7843660e8203ed6e1af9bfd23e14f">dnnl_engine_t</a> engine, void *handle)</td></tr>
<tr class="memdesc:ga52a9246bd7f4e498b08d61e75e689a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory for given <code>memory_desc</code> and <code>engine</code>.  <a href="#ga52a9246bd7f4e498b08d61e75e689a0c">More...</a><br /></td></tr>
<tr class="separator:ga52a9246bd7f4e498b08d61e75e689a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a447af4c51aba057856c7b596351d4"><td class="memItemLeft" align="right" valign="top"><a id="ga59a447af4c51aba057856c7b596351d4"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga59a447af4c51aba057856c7b596351d4">dnnl_memory_get_memory_desc</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> **memory_desc)</td></tr>
<tr class="memdesc:ga59a447af4c51aba057856c7b596351d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>memory_desc</code> associated with <code>memory</code>. <br /></td></tr>
<tr class="separator:ga59a447af4c51aba057856c7b596351d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583a4a06428de7d6c4251313e57ad814"><td class="memItemLeft" align="right" valign="top"><a id="ga583a4a06428de7d6c4251313e57ad814"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga583a4a06428de7d6c4251313e57ad814">dnnl_memory_get_engine</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, <a class="el" href="group__c__api__engine__types.html#ga1ce7843660e8203ed6e1af9bfd23e14f">dnnl_engine_t</a> *engine)</td></tr>
<tr class="memdesc:ga583a4a06428de7d6c4251313e57ad814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>engine</code> associated with <code>memory</code>. <br /></td></tr>
<tr class="separator:ga583a4a06428de7d6c4251313e57ad814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9006cdf6816b8bef7be3455ab0ceb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gac9006cdf6816b8bef7be3455ab0ceb49">dnnl_memory_map_data</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, void **mapped_ptr)</td></tr>
<tr class="memdesc:gac9006cdf6816b8bef7be3455ab0ceb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code>, maps the data of the memory to <code>mapped_ptr</code>.  <a href="#gac9006cdf6816b8bef7be3455ab0ceb49">More...</a><br /></td></tr>
<tr class="separator:gac9006cdf6816b8bef7be3455ab0ceb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46dd4eb02eade91cadd0b9f85b4eccd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga46dd4eb02eade91cadd0b9f85b4eccd4">dnnl_memory_unmap_data</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, void *mapped_ptr)</td></tr>
<tr class="memdesc:ga46dd4eb02eade91cadd0b9f85b4eccd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code>, unmaps a mapped pointer to the data of the memory.  <a href="#ga46dd4eb02eade91cadd0b9f85b4eccd4">More...</a><br /></td></tr>
<tr class="separator:ga46dd4eb02eade91cadd0b9f85b4eccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71efa7bd0ac194fdec98fb908b8ba9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga71efa7bd0ac194fdec98fb908b8ba9c5">dnnl_memory_get_data_handle</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, void **handle)</td></tr>
<tr class="memdesc:ga71efa7bd0ac194fdec98fb908b8ba9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code>, returns the data <code>handle</code>.  <a href="#ga71efa7bd0ac194fdec98fb908b8ba9c5">More...</a><br /></td></tr>
<tr class="separator:ga71efa7bd0ac194fdec98fb908b8ba9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6888f8c17f272d6729c9bc258ed41fcf"><td class="memItemLeft" align="right" valign="top"><a id="ga6888f8c17f272d6729c9bc258ed41fcf"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#ga6888f8c17f272d6729c9bc258ed41fcf">dnnl_memory_set_data_handle</a> (<a class="el" href="group__c__api__types__memory.html#ga2b79954bd7bb293e766a89189e8440fd">dnnl_memory_t</a> memory, void *handle)</td></tr>
<tr class="memdesc:ga6888f8c17f272d6729c9bc258ed41fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code>, sets the data <code>handle</code>. <br /></td></tr>
<tr class="separator:ga6888f8c17f272d6729c9bc258ed41fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f56c1bdffa7889ee408445883cca16"><td class="memItemLeft" align="right" valign="top"><a id="gaf0f56c1bdffa7889ee408445883cca16"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gaf0f56c1bdffa7889ee408445883cca16">dnnl_memory_get_ocl_mem_object</a> (<a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a> memory, cl_mem *mem_object)</td></tr>
<tr class="memdesc:gaf0f56c1bdffa7889ee408445883cca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code> returns the OpenCL memory object associated with it. <br /></td></tr>
<tr class="separator:gaf0f56c1bdffa7889ee408445883cca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fb998362d50ce9014cb2988c209016"><td class="memItemLeft" align="right" valign="top"><a id="gad8fb998362d50ce9014cb2988c209016"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gad8fb998362d50ce9014cb2988c209016">dnnl_memory_set_ocl_mem_object</a> (<a class="el" href="group__c__api__types__memory.html#ga2b79954bd7bb293e766a89189e8440fd">dnnl_memory_t</a> memory, cl_mem mem_object)</td></tr>
<tr class="memdesc:gad8fb998362d50ce9014cb2988c209016"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memory</code> sets the OpenCL memory object associated with it. <br /></td></tr>
<tr class="separator:gad8fb998362d50ce9014cb2988c209016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa219225aae8e53489caab3fe1bc80a52"><td class="memItemLeft" align="right" valign="top"><a id="gaa219225aae8e53489caab3fe1bc80a52"></a>
<a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__c__api__memory.html#gaa219225aae8e53489caab3fe1bc80a52">dnnl_memory_destroy</a> (<a class="el" href="group__c__api__types__memory.html#ga2b79954bd7bb293e766a89189e8440fd">dnnl_memory_t</a> memory)</td></tr>
<tr class="memdesc:gaa219225aae8e53489caab3fe1bc80a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a <code>memory</code>. <br /></td></tr>
<tr class="separator:gaa219225aae8e53489caab3fe1bc80a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A primitive to describe and store data. </p>
<p>The library supports various data types and formats. Memory hierarchy consists of three levels of abstraction:</p><ol type="1">
<li><b>Memory descriptor</b> &ndash; engine agnostic logical description of data (number of dimensions, dimensions themselves, and data type), and optionally the format/layout that describes the physical representation of data in memory. If the format is not known yet, one can pass <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dafee39ac6fff0325cae43cd66495c18ac" title="Undefined memory format tag. ">dnnl_format_tag_any</a>. This approach is used to allow compute-intensive primitives to specify the most appropriate format on their own with users required to reorder the data if the incoming format doesn't match the primitive's selection. Memory descriptor can be initialized with <a class="el" href="group__c__api__memory.html#gaff696e368aeefb3036a0419c508dc6be" title="Initializes a memory_desc memory descriptor using ndims, dims, data_type, and format tag...">dnnl_memory_desc_init_by_tag()</a> or <a class="el" href="group__c__api__memory.html#ga77c4ac2c6c59730ade594b954c145f73" title="Initializes a memory_desc memory descriptor using ndims, dims, data_type, and strides. ">dnnl_memory_desc_init_by_strides()</a> functions, or by directly filling the <a class="el" href="structdnnl__memory__desc__t.html" title="Memory descriptor. ">dnnl_memory_desc_t</a> structure. The latter requires deep knowledge of how the physical data representation is mapped to the structure. The <a class="el" href="dev_guide_understanding_memory_formats.html">Understanding Memory Formats</a> topic should shed some light on that. For the fully defined memory descriptors (i.e. where the format kind is not equal to <a class="el" href="group__c__api__types__generic.html#ggaa75cad747fa467d9dc527d943ba3367da77ae35388e04dc3e98d90675a7110c83" title="Unspecified format kind. ">dnnl_format_kind_any</a>) a user can the size, using the <a class="el" href="group__c__api__memory.html#gaed039afa75d9f56763e2c1321f1563c4" title="Returns the size (in bytes) that is required for given memory_desc. ">dnnl_memory_desc_get_size()</a> function. As described in <a class="el" href="dev_guide_understanding_memory_formats.html">Understanding Memory Formats</a>, the size of data sometimes cannot be computed as the product of dimensions times the size of the data type. So users are encouraged to use this function for better code portability. Two memory descriptors can be compared with <a class="el" href="group__c__api__memory.html#gaa734e01591b567ed6378df1f404058e2" title="Compares two memory descriptors. ">dnnl_memory_desc_equal()</a>. The comparison is especially useful when checking whether a primitive requires reorder from the user's data format to the primitive's format.</li>
<li><b>Memory</b> &ndash; an engine-specific object that handles the data and its description (a memory descriptor). For CPU enigne, the data handle is simply a pointer to <code>void</code>. The data handle can be queried using <a class="el" href="group__c__api__memory.html#ga71efa7bd0ac194fdec98fb908b8ba9c5" title="For a memory, returns the data handle. ">dnnl_memory_get_data_handle()</a> and set using <a class="el" href="group__c__api__memory.html#ga6888f8c17f272d6729c9bc258ed41fcf" title="For a memory, sets the data handle. ">dnnl_memory_set_data_handle()</a>. The latter function always sets the memory in the padding region to zero, which is the invariant maintained by all the primitives in DNNL. See <a class="el" href="dev_guide_understanding_memory_formats.html">Understanding Memory Formats</a> for more details. A memory can be created using <a class="el" href="group__c__api__memory.html#ga52a9246bd7f4e498b08d61e75e689a0c" title="Creates a memory for given memory_desc and engine. ">dnnl_memory_create()</a> function. A memory can also be queried for the underlying memory descriptor and engine using <a class="el" href="group__c__api__memory.html#ga59a447af4c51aba057856c7b596351d4" title="Returns a memory_desc associated with memory. ">dnnl_memory_get_memory_desc()</a> and <a class="el" href="group__c__api__memory.html#ga583a4a06428de7d6c4251313e57ad814" title="Returns an engine associated with memory. ">dnnl_memory_get_engine()</a> functions.</li>
</ol>
<p>Along with ordinary memory with all dimensions being positive, Intel DNNL supports <em>zero-volume</em> memory with one or more dimensions set to zero. This is to support the NumPy* convention. If a <em>zero-volume</em> memory is passed to a primitive, the primitive does not perform any computations on this memory. For example:</p><ul>
<li>Convolution with <code>(0 batch, 3 input channels, 13 height, 13 width)</code> source and <code>(16 output channels, 3 input channels, 3 height, 3 width)</code> weights would produce <code>(0 batch, 16 output channels, 11 height, 11 width)</code> destination (assuming strides are <code>1</code> and paddings are zero) and perform zero multiply-add operations.</li>
<li>Concatenation of three memories of shapes <code>(3, 4, 13, 13)</code>, <code>(3, 0, 13, 13)</code>, and <code>(3, 1, 13, 13)</code> along the second axis would produce the output of the shape <code>(3, 5, 13, 13)</code>, effectively ignoring the second input (however, if the user created a concatenation primitive descriptor with three inputs they should also provide all three memories to the concatenation primitive, including the one with zero second dimension).</li>
<li>However, DNNL would return an error when attempting to create a convolution with <em>zero-volume</em> memory passed for weights because such a convolution is not well-defined: <div class="fragment"><div class="line">dst(1, 16, 11, 11) &lt;-- src(1, 0, 13, 13) (*) wei(16, 0, 3, 3)</div></div><!-- fragment --> Should the values in the destination be zeroes or just not accessed at all? Moreover, backward pass w.r.t. weights in such cases is also not well-defined.</li>
</ul>
<p>Data handle of <em>zero-volume</em> memory is never accessed and hence can be unset (NULL in case of CPU engine).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dev_guide_understanding_memory_formats.html">Understanding Memory Formats</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga77c4ac2c6c59730ade594b954c145f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c4ac2c6c59730ade594b954c145f73">&#9670;&nbsp;</a></span>dnnl_memory_desc_init_by_strides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_desc_init_by_strides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c__api__types__generic.html#ga012ba1c84ff24bdd068f9d2f9b26a130">dnnl_data_type_t</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>memory_desc</code> memory descriptor using <code>ndims</code>, <code>dims</code>, <code>data_type</code>, and <code>strides</code>. </p>
<p>The <code>strides</code> might be NULL, which means the order of physical dimensions is the same as the order of logical ones.</p>
<dl class="section note"><dt>Note</dt><dd>The logical order of dimensions is defined by a primitive that consumes the memory. </dd></dl>

</div>
</div>
<a id="gaff696e368aeefb3036a0419c508dc6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff696e368aeefb3036a0419c508dc6be">&#9670;&nbsp;</a></span>dnnl_memory_desc_init_by_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_desc_init_by_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c__api__types__generic.html#ga012ba1c84ff24bdd068f9d2f9b26a130">dnnl_data_type_t</a>&#160;</td>
          <td class="paramname"><em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c__api__types__generic.html#ga395e42b594683adb25ed2d842bb3091d">dnnl_format_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>memory_desc</code> memory descriptor using <code>ndims</code>, <code>dims</code>, <code>data_type</code>, and format <code>tag</code>. </p>
<p><code>tag</code> can be <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dafee39ac6fff0325cae43cd66495c18ac" title="Undefined memory format tag. ">dnnl_format_tag_any</a>, which allows a primitive to define the appropriate memory format. In this case, the <code>format_kind</code> would be set to <a class="el" href="group__c__api__types__generic.html#ggaa75cad747fa467d9dc527d943ba3367da77ae35388e04dc3e98d90675a7110c83" title="Unspecified format kind. ">dnnl_format_kind_any</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cnn_inference_f32_8c-example.html#a7">cnn_inference_f32.c</a>, <a class="el" href="cpu_cnn_training_f32_8c-example.html#a6">cpu_cnn_training_f32.c</a>, and <a class="el" href="cross_engine_reorder_8c-example.html#a8">cross_engine_reorder.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga21b56f5755bb767c60b4f1b3dfc34445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b56f5755bb767c60b4f1b3dfc34445">&#9670;&nbsp;</a></span>dnnl_memory_desc_init_submemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_desc_init_submemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>parent_memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code>memory_desc</code> for a given <code>parent_memory_desc</code>, with <code>dims</code> sizes and <code>offsets</code>. </p>
<p>May fail if layout used does not allow obtain desired submemory. In this case consider using <code>extract</code> or <code>insert</code> primitive </p>

</div>
</div>
<a id="ga5994f41ff7305a203aacce192d4eac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5994f41ff7305a203aacce192d4eac35">&#9670;&nbsp;</a></span>dnnl_memory_desc_reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_desc_reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>out_memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>in_memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c__api__types__memory.html#ga8331e1160e52a5d4babe96736464095a">dnnl_dims_t</a>&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>out_memory_desc</code> with new <code>ndims</code> and <code>dims</code> from a <code>in_memory_desc</code>. </p>
<p>If <code>in_memory_desc</code> and <code>out_memory_desc</code> point to the same memory descriptor, then <code>in_memory_desc</code> is re-initialized with new values. <code>out_memory_desc</code> inherits data type from <code>in_memory_desc</code> and has same blocked format_kind. Others format_kind's are not supported.</p>
<dl class="section note"><dt>Note</dt><dd>Limitation: the only currently supported reshape operation is appending 1-sized dimensions to the end. </dd></dl>

</div>
</div>
<a id="gaa734e01591b567ed6378df1f404058e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa734e01591b567ed6378df1f404058e2">&#9670;&nbsp;</a></span>dnnl_memory_desc_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DNNL_API dnnl_memory_desc_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two memory descriptors. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the descriptors are the same. </dd>
<dd>
0 if the descriptors are different.</dd></dl>
<p>Use this function to identify whether a reorder is required between the two memories </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cnn_inference_f32_8c-example.html#a12">cnn_inference_f32.c</a>, and <a class="el" href="cpu_cnn_training_f32_8c-example.html#a12">cpu_cnn_training_f32.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga52a9246bd7f4e498b08d61e75e689a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a9246bd7f4e498b08d61e75e689a0c">&#9670;&nbsp;</a></span>dnnl_memory_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c__api__types__memory.html#ga2b79954bd7bb293e766a89189e8440fd">dnnl_memory_t</a> *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> *&#160;</td>
          <td class="paramname"><em>memory_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c__api__engine__types.html#ga1ce7843660e8203ed6e1af9bfd23e14f">dnnl_engine_t</a>&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memory for given <code>memory_desc</code> and <code>engine</code>. </p>
<p>Also sets <code>handle</code> to one of the following:</p><ul>
<li>pointer to the user allocated memory, i.e. valid handle. In this case the library doesn't own allocated memory.</li>
<li>DNNL_MEMORY_ALLOCATE to ask the library to allocate and attach memory. In this case the library owns allocated memory.</li>
<li>DNNL_MEMORY_NONE to create <a class="el" href="structdnnl__memory.html" title="An opaque structure to describe a memory. ">dnnl_memory</a> w/o attached memory. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cnn_inference_f32_8c-example.html#a8">cnn_inference_f32.c</a>, <a class="el" href="cpu_cnn_training_f32_8c-example.html#a8">cpu_cnn_training_f32.c</a>, and <a class="el" href="cross_engine_reorder_8c-example.html#a11">cross_engine_reorder.c</a>.</dd>
</dl>
</div>
</div>
<a id="gac9006cdf6816b8bef7be3455ab0ceb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9006cdf6816b8bef7be3455ab0ceb49">&#9670;&nbsp;</a></span>dnnl_memory_map_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_map_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a>&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mapped_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <code>memory</code>, maps the data of the memory to <code>mapped_ptr</code>. </p>
<p>Mapping allows to read/write directly from/to the memory contents for engines that do not support direct memory access.</p>
<p>Mapping is an exclusive operation - a memory object cannot be used in other operations until this memory object is unmapped.</p>
<dl class="section note"><dt>Note</dt><dd>Any primitives working with <code>memory</code> should be completed before mapping the memory. Use dnnl_stream_wait to synchronize the corresponding execution stream.</dd>
<dd>
Map/unmap API is provided mainly for debug/testing purposes and its performance may be suboptimal. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross_engine_reorder_8c-example.html#a1">cross_engine_reorder.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga46dd4eb02eade91cadd0b9f85b4eccd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46dd4eb02eade91cadd0b9f85b4eccd4">&#9670;&nbsp;</a></span>dnnl_memory_unmap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_unmap_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a>&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapped_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <code>memory</code>, unmaps a mapped pointer to the data of the memory. </p>
<p>Any changes of the mapped data are synchronized back to the memory after the call is complete. The mapped pointer must be obtained through a dnnl_memory_map_data call.</p>
<dl class="section note"><dt>Note</dt><dd>Map/unmap API is provided mainly for debug/testing purposes and its performance may be suboptimal. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross_engine_reorder_8c-example.html#a2">cross_engine_reorder.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga71efa7bd0ac194fdec98fb908b8ba9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71efa7bd0ac194fdec98fb908b8ba9c5">&#9670;&nbsp;</a></span>dnnl_memory_get_data_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__c__api__types__generic.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a> DNNL_API dnnl_memory_get_data_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c__api__types__memory.html#ga0f89ee8e9b55b302b3f5277d11302f7e">const_dnnl_memory_t</a>&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <code>memory</code>, returns the data <code>handle</code>. </p>
<p>For the CPU engine, the data handle is a pointer to the actual data. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cpu_cnn_training_f32_8c-example.html#a55">cpu_cnn_training_f32.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>