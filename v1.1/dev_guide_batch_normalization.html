<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>DNNL: Batch Normalization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Deep Neural Network Library (DNNL)
   &#160;<span id="projectnumber">1.1.3</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Batch Normalization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p></p>
<p>API reference: <a class="el" href="group__c__api__batch__normalization.html">C</a>, <a class="el" href="group__cpp__api__batch__normalization.html">C++</a></p>
<p></p>
</blockquote>
<p>The batch normalization primitive performs a forward or backward batch normalization operation on 0D, 2D, or 3D spatial data.</p>
<p>The batch normalization operation is defined by the following formulas. We show formulas only for 2D spatial data which are straightforward to generalize to cases of higher and lower dimensions. Variable names follow the standard <a class="el" href="dev_guide_conventions.html">Naming Conventions</a>.</p>
<h3>Forward</h3>
<p class="formulaDsp">
\[ dst(n, c, h, w) = \gamma(c) \cdot \frac{src(n, c, h, w) - \mu(c)} {\sqrt{\sigma^2(c) + \varepsilon}} + \beta(c), \]
</p>
<p>where</p>
<ul>
<li>\(\gamma(c), \beta(c)\) are optional scale and shift for a channel (see <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aeba5189d91e23448d706fb027867ae55" title="Use scale and shift parameters. ">dnnl_use_scaleshift</a> flag),</li>
<li>\(\mu(c), \sigma^2(c)\) are computed at run-time or provided by a user mean and variance for channel (see <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aec04425c28af752c0f8b4dc5ae11fb19" title="Use global statistics. ">dnnl_use_global_stats</a> flag), and</li>
<li>\(\varepsilon\) is a constant to improve numerical stability.</li>
</ul>
<p>When mean and variance are computed at a run-time the following formulas are used:</p>
<ul>
<li>\(\mu(c) = \frac{1}{NHW} \sum\limits_{nhw} src(n, c, h, w)_{}\),</li>
<li>\(\sigma^2(c) = \frac{1}{NHW} \sum\limits_{nhw} {}_{} (src(n, c, h, w) - \mu(c))^2\).</li>
</ul>
<p>The \(\gamma(c)\) and \(\beta(c)\) tensors are considered learnable.</p>
<p>In training mode the primitive also optionally supports fusion with ReLU activation with zero negative slope applied to the result (see <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3a7150bdb66ef194e6ee11fbaa85a34ada" title="Fuse with ReLU. ">dnnl_fuse_norm_relu</a> flag).</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The batch normalization primitive computes population mean and variance and not their sample or unbiased versions that are typically used to compute running mean and variance.</li>
<li>Using the mean and variance computed by the batch normalization primitive, running mean and variance \(\hat\mu\) and \(\hat\sigma^2\) can be computed as <p class="formulaDsp">
\[ \hat\mu := \alpha \cdot \hat\mu + (1 - \alpha) \cdot \mu, \\ \hat\sigma^2 := \alpha \cdot \hat\sigma^2 + (1 - \alpha) \cdot \sigma^2. \]
</p>
</li>
</ul>
</dd></dl>
<h4>Difference Between <a href="#dnnl_forward_training">Forward Training</a> and <a href="#dnnl_forward_inference">Forward Inference</a></h4>
<ul>
<li>If mean and variance are computed at run-time (i.e., <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aec04425c28af752c0f8b4dc5ae11fb19" title="Use global statistics. ">dnnl_use_global_stats</a> is not set), they become outputs for the propagation kind <a class="el" href="group__c__api__types__generic.html#ggae3c1f22ae55645782923fbfd8b07d0c4a992e03bebfe623ac876b3636333bbce0" title="Forward data propagation (training mode). ">dnnl_forward_training</a> (since they would be required during the backward propagation) and are not exposed for the propagation kind <a class="el" href="group__c__api__types__generic.html#ggae3c1f22ae55645782923fbfd8b07d0c4a2f77a568a675dec649eb0450c997856d" title="Forward data propagation (inference mode). ">dnnl_forward_inference</a>.</li>
<li>If batch normalization is created with ReLU fusion (i.e., <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3a7150bdb66ef194e6ee11fbaa85a34ada" title="Fuse with ReLU. ">dnnl_fuse_norm_relu</a> is set), for the propagation kind <a class="el" href="group__c__api__types__generic.html#ggae3c1f22ae55645782923fbfd8b07d0c4a992e03bebfe623ac876b3636333bbce0" title="Forward data propagation (training mode). ">dnnl_forward_training</a> the primitive would produce a <code>workspace</code> memory as one extra output. This memory is required to compute the backward propagation. When the primitive is executed with propagation kind <a class="el" href="group__c__api__types__generic.html#ggae3c1f22ae55645782923fbfd8b07d0c4a2f77a568a675dec649eb0450c997856d" title="Forward data propagation (inference mode). ">dnnl_forward_inference</a>, the workspace is not produced. Behavior would be the same as creating a batch normalization primitive with ReLU as a post-op (see section below).</li>
</ul>
<h3>Backward</h3>
<p>The backward propagation computes \(diff\_src(n, c, h, w)\), \(diff\_\gamma(c)^*\), and \(diff\_\beta(c)^*\) based on \(diff\_dst(n, c, h, w)\), \(src(n, c, h, w)\), \(\mu(c)\), \(\sigma^2(c)\), \(\gamma(c) ^*\), and \(\beta(c) ^*\).</p>
<p>The tensors marked with an asterisk are used only when the primitive is configured to use \(\gamma(c)\), and \(\beta(c)\) (i.e., <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aeba5189d91e23448d706fb027867ae55" title="Use scale and shift parameters. ">dnnl_use_scaleshift</a> is set).</p>
<h2>Execution Arguments</h2>
<p>Depending on the <a class="el" href="group__c__api__types__generic.html#ga301f673522a400c7c1e75f518431c9a3">flags</a> and <a class="el" href="group__c__api__types__generic.html#gae3c1f22ae55645782923fbfd8b07d0c4">propagation kind</a>, the batch normalization primitive requires different inputs and outputs. For clarity, the summary table is shown below.</p>
<blockquote class="doxtable">
<p>TODO: add? </p>
</blockquote>
<h2>Implementation Details</h2>
<h3>General Notes</h3>
<ol type="1">
<li>The different flavors of the primitive are partially controlled by the <code>flags</code> parameter that is passed to the operation descriptor initialization function (e.g., <a class="el" href="structdnnl_1_1batch__normalization__forward_1_1desc.html#abb3cbd4239c50319cc24d3770bf6d8e5" title="Initializes a batch normalization descriptor for forward propagation using prop_kind (possible values...">dnnl::batch_normalization_forward::desc::desc()</a>). Multiple flags can be set using the bitwise OR operator (<code>|</code>).</li>
<li>For forward propagation, the mean and variance might be either computed at run-time (in which case they are outputs of the primitive) or provided by a user (in which case they are inputs). In the latter case, a user must set the <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aec04425c28af752c0f8b4dc5ae11fb19" title="Use global statistics. ">dnnl_use_global_stats</a> flag. For the backward propagation, the mean and variance are always input parameters.</li>
<li>The memory format and data type for <code>src</code> and <code>dst</code> are assumed to be the same, and in the API are typically referred as <code>data</code> (e.g., see <code>data_desc</code> in <a class="el" href="structdnnl_1_1batch__normalization__forward_1_1desc.html#abb3cbd4239c50319cc24d3770bf6d8e5" title="Initializes a batch normalization descriptor for forward propagation using prop_kind (possible values...">dnnl::batch_normalization_forward::desc::desc()</a>). The same holds for <code>diff_src</code> and <code>diff_dst</code>. The corresponding memory descriptors are referred to as <code>diff_data_desc</code>.</li>
<li>Both forward and backward propagation support in-place operations, meaning that <code>src</code> can be used as input and output for forward propagation, and <code>diff_dst</code> can be used as input and output for backward propagation. In case of in-place operation, the original data will be overwritten.</li>
<li>As mentioned above, the batch normalization primitive can be fused with ReLU activation even in the training mode. In this case, on the forward propagation the primitive has one additional output, <code>workspace</code>, that should be passed during the backward propagation.</li>
</ol>
<h3>Data Type Support</h3>
<p>The operation supports the following combinations of data types:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Propagation  </th><th class="markdownTableHeadLeft">Source / Destination  </th><th class="markdownTableHeadLeft">Mea   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">forward / backward  </td><td class="markdownTableBodyLeft">f32, bf16  </td><td class="markdownTableBodyLeft">f32   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">forward  </td><td class="markdownTableBodyLeft">f16  </td><td class="markdownTableBodyLeft">f32   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">forward  </td><td class="markdownTableBodyLeft">s8  </td><td class="markdownTableBodyLeft">f32   </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>There might be hardware and/or implementation specific restrictions. Check <a class="el" href="dev_guide_batch_normalization.html#dg_bnorm_impl_limits">Implementation Limitations</a> section below.</dd></dl>
<h3>Data Representation</h3>
<h4>Mean and Variance</h4>
<p>The mean ( \(\mu\)) and variance ( \(\sigma^2\)) are separate 1D tensors of size \(C\).</p>
<p>The format of the corresponding memory object must be <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da9ccb37bb1a788f0245efbffbaf81e145" title="1D tensor, an alias to dnnl_a ">dnnl_x</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da7a72c401669bf1737439d6c4af17d0be" title="plain 1D tensor ">dnnl_a</a>).</p>
<h4>Scale and Shift</h4>
<p>If used, the scale ( \(\gamma\)) and shift ( \(\beta\)) are combined in a single 2D tensor of shape \(2 \times C\).</p>
<p>The format of the corresponding memory object must be <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dac08a541001fe70289305a5fbde48906d" title="2D CNN activations tensor, an alias to dnnl_ab ">dnnl_nc</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da1bd907fc29344dfe7ba88336960dcf53" title="plain 2D tensor ">dnnl_ab</a>).</p>
<h4>Source, Destination, and Their Gradients</h4>
<p>Like other CNN primitives, the batch normalization primitive expects data to be \(N \times C \times SP_n \times \cdots \times SP_0\) tensor.</p>
<p>The batch normalization primitive is optimized for the following memory formats:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Spatial  </th><th class="markdownTableHeadLeft">Logical tensor  </th><th class="markdownTableHeadLeft">Imp   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">0D  </td><td class="markdownTableBodyLeft">NC  </td><td class="markdownTableBodyLeft"><a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dac08a541001fe70289305a5fbde48906d" title="2D CNN activations tensor, an alias to dnnl_ab ">dnnl_nc</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da1bd907fc29344dfe7ba88336960dcf53" title="plain 2D tensor ">dnnl_ab</a>)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">2D  </td><td class="markdownTableBodyLeft">NCHW  </td><td class="markdownTableBodyLeft"><a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da83a751aedeb59613312339d0f8b90f54" title="4D CNN activations tensor, an alias to dnnl_abcd ">dnnl_nchw</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da6e669cc61278663a5ddbd3d0b25c6c5c" title="plain 4D tensor ">dnnl_abcd</a>), <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dae50c534446b3c18cc018b3946b3cebd7" title="4D CNN activations tensor, an alias to dnnl_acdb ">dnnl_nhwc</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da8fcce5dd7260b5b0740e3b37b1e9ad41" title="permuted 4D tensor ">dnnl_acdb</a>), <em>optimized^</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">3D  </td><td class="markdownTableBodyLeft">NCDHW  </td><td class="markdownTableBodyLeft"><a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091dae33b8c6790e5d37324f18a019658d464" title="5D CNN activations tensor, an alias to dnnl_abcde ">dnnl_ncdhw</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da30d5d3c9de2931f06d265af81787ada3" title="plain 5D tensor ">dnnl_abcde</a>), <a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091daa0d8b24eefd029e214080d3787114fc2" title="5D CNN activations tensor, an alias to dnnl_acdeb ">dnnl_ndhwc</a> (<a class="el" href="group__c__api__types__generic.html#gga395e42b594683adb25ed2d842bb3091da0cfe86402763786b9b4d73062cfd2f05" title="permuted 5D tensor ">dnnl_acdeb</a>), <em>optimized^</em>   </td></tr>
</table>
<p>Here <em>optimized^</em> means the format that <a class="el" href="memory_format_propagation_cpp.html">comes out</a> of any preceding compute-intensive primitive.</p>
<h3>Post-ops and Attributes</h3>
<p>Post-ops and attributes enable you to modify the behavior of the batch normalization primitive by chaining certain operations after the batch normalization operation. The following post-ops are supported by batch normalization primitives:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Propagation  </th><th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Operation  </th><th class="markdownTableHeadLeft">Des   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">forward  </td><td class="markdownTableBodyLeft">post-op  </td><td class="markdownTableBodyLeft">eltwise  </td><td class="markdownTableBodyLeft">Applies an <a class="el" href="group__c__api__eltwise.html">Eltwise</a> operation to the result (currently only <a class="el" href="group__c__api__types__generic.html#gga96946c805f6c4922c38c37049ab95d23a5e37643fec6531331e2e38df68d4c65a" title="Eltwise: ReLU. ">dnnl_eltwise_relu</a> algorithm is supported)   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>As mentioned in <a class="el" href="dev_guide_attributes.html">Primitive Attributes</a>, the post-ops should be used for inference only. For instance, using ReLU as a post-op would not produce an additional output <code>workspace</code> that is required to compute backward propagation correctly. Hence, in case of training one should use the <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3a7150bdb66ef194e6ee11fbaa85a34ada" title="Fuse with ReLU. ">dnnl_fuse_norm_relu</a> directly.</dd></dl>
<p><a class="anchor" id="dg_bnorm_impl_limits"></a></p><h2>Implementation Limitations</h2>
<ol type="1">
<li>Refer to <a class="el" href="dev_guide_data_types.html">Data Types</a> for limitations related to data types support.</li>
<li>For the data types that have forward propagation support only, mean and variance must be provided by a user (i.e., <a class="el" href="group__c__api__types__generic.html#gga301f673522a400c7c1e75f518431c9a3aec04425c28af752c0f8b4dc5ae11fb19" title="Use global statistics. ">dnnl_use_global_stats</a> is not set).</li>
</ol>
<h2>Performance Tips</h2>
<ol type="1">
<li>For backward propagation, use the same memory format for <code>src</code>, <code>diff_dst</code>, and <code>diff_src</code> (the format of the <code>diff_dst</code> and <code>diff_src</code> are always the same because of the API). Different formats are functionally supported but lead to highly suboptimal performance.</li>
<li>Use in-place operations whenever possible. </li>
</ol>
</div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>