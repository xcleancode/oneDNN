<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>DNNL: Matrix Multiplication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">Deep Neural Network Library (DNNL)
   &#160;<span id="projectnumber">1.2.2</span>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Matrix Multiplication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p></p>
<p><a class="el" href="group__dnnl__api__matmul.html">API Reference</a></p>
<p></p>
</blockquote>
<p>The matrix multiplication (MatMul) primitive computes the product of two 2D tensors with optional bias addition:</p>
<p class="formulaDsp">
\[ dst(m, n) = \sum_{k=0}^{K} \left( src(m, k) \cdot weights(k, n) \right) + bias(m, n) \]
</p>
<p>The MatMul primitive also supports batching multiple independent matrix multiplication operations, in which case the tensors must be 3D:</p>
<p class="formulaDsp">
\[ dst(mb, m, n) = \sum_{k=0}^{K} \left( src(mb, m, k) \cdot weights(mb, k, n) \right) + bias(mb, m, n) \]
</p>
<p>The bias tensor is optional and supports implicit broadcast semantics: any of its dimensions can be 1 and the same value would be used across the corresponding dimension. However, \(bias\) must have the same number of dimensions as the \(dst\).</p>
<h2>Implementation Details</h2>
<h3>General Notes</h3>
<ol type="1">
<li><p class="startli">The MatMul primitive supports input and output tensors with run-time specified shapes and memory formats. The run-time specified dimensions or strides are specified using the <a class="el" href="group__dnnl__api__memory.html#gaa596c5a6102df77a550bad98f0d5cc12" title="A wildcard value for dimensions that are unknown at a primitive creation time. ">DNNL_RUNTIME_DIM_VAL</a> wildcard value during the primitive initialization and creation stage. At the execution stage, the user must pass fully specified memory objects so that the primitive is able to perform the computations. Note that the less information about shapes or format is available at the creation stage, the less performant execution will be. In particular, if the shape is not known at creation stage, one cannot use the special format tag <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> to enable an implementation to choose the most appropriate memory format for the corresponding input or output shapes. On the other hand, run-time specified shapes enable users to create a primitive once and use it in different situations.</p>
<dl class="section see"><dt>See also</dt><dd>Please check tutorials below to see <a class="el" href="group__dnnl__api__memory.html#gaa596c5a6102df77a550bad98f0d5cc12" title="A wildcard value for dimensions that are unknown at a primitive creation time. ">DNNL_RUNTIME_DIM_VAL</a> support in use.</dd></dl>
<h3>Data Types</h3>
</li>
</ol>
<p>The MatMul primitive supports the following combinations of data types for source, destination, weights, and bias tensors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Source  </th><th class="markdownTableHeadLeft">Weights  </th><th class="markdownTableHeadLeft">Destination  </th><th class="markdownTableHeadLeft">Bias   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">f32  </td><td class="markdownTableBodyLeft">f32  </td><td class="markdownTableBodyLeft">f32  </td><td class="markdownTableBodyLeft">f32   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">f16  </td><td class="markdownTableBodyLeft">f16  </td><td class="markdownTableBodyLeft">f16  </td><td class="markdownTableBodyLeft">f16   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">bf16  </td><td class="markdownTableBodyLeft">bf16  </td><td class="markdownTableBodyLeft">bf16  </td><td class="markdownTableBodyLeft">bf16, f32   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u8, s8  </td><td class="markdownTableBodyLeft">s8, u8  </td><td class="markdownTableBodyLeft">u8, s8, s32, f32  </td><td class="markdownTableBodyLeft">u8, s8, s32, f32   </td></tr>
</table>
<h3>Data Representation</h3>
<p>The MatMul primitive expects the following tensors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Dims  </th><th class="markdownTableHeadLeft">Source  </th><th class="markdownTableHeadLeft">Weights  </th><th class="markdownTableHeadLeft">Destination  </th><th class="markdownTableHeadLeft">Bias   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2D  </td><td class="markdownTableBodyLeft">\(M \times K\)  </td><td class="markdownTableBodyLeft">\(K \times N\)  </td><td class="markdownTableBodyLeft">\(M \times N\)  </td><td class="markdownTableBodyLeft">None or \((M \text{ or } 1) \times (N \text{ or } 1)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">3D  </td><td class="markdownTableBodyLeft">\(MB \times M \times K\)  </td><td class="markdownTableBodyLeft">\(MB \times K \times N\)  </td><td class="markdownTableBodyLeft">\(MB \times M \times N\)  </td><td class="markdownTableBodyLeft">None or \((MB \text{ or } 1) \times (M \text{ or } 1) \times (N \text{ or } 1)\)   </td></tr>
</table>
<p>The MatMul primitive is generally optimized for the case in which memory objects use plain memory formats (with some restrictions; see the table below). However, it is recommended to use the placeholder memory format <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> if an input tensor is reused across multiple executions. In this case, the primitive will set the most appropriate memory format for the corresponding input tensor.</p>
<p>The table below shows the combinations of memory formats for which the MatMul primitive is optimized. The memory format of the destination tensor should always be <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa187ef4436122d1cc2f40dc2b92f0eba0" title="plain 2D tensor ">dnnl::memory::format_tag::ab</a> for the 2D case and <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa900150983cd24fb0d6963f7d28e17f72" title="plain 3D tensor ">dnnl::memory::format_tag::abc</a> for the 3D one.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Dims  </th><th class="markdownTableHeadLeft">Logical tensors  </th><th class="markdownTableHeadLeft">Mat   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2D  </td><td class="markdownTableBodyLeft">Source: \(M \times K\) <br />
 Weights: \(K \times N\)  </td><td class="markdownTableBodyLeft">Source: <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da1bd907fc29344dfe7ba88336960dcf53" title="plain 2D tensor ">dnnl_ab</a> or <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da6a6dbc0b30468d92e32a9cb3f6615c43" title="permuted 2D tensor ">dnnl_ba</a> <br />
 Weights: <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da1bd907fc29344dfe7ba88336960dcf53" title="plain 2D tensor ">dnnl_ab</a> or <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091da6a6dbc0b30468d92e32a9cb3f6615c43" title="permuted 2D tensor ">dnnl_ba</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">3D  </td><td class="markdownTableBodyLeft">Source: \(MB \times M \times K\) <br />
 Weights: \(MB \times K \times N\)  </td><td class="markdownTableBodyLeft">Source: <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dadff5ea69392d7e4da23179dc0ba7cbc2" title="plain 3D tensor ">dnnl_abc</a> or <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daf8537ed269eb5d0586456db114039c00" title="permuted 3D tensor ">dnnl_acb</a> <br />
 Weights: <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091dadff5ea69392d7e4da23179dc0ba7cbc2" title="plain 3D tensor ">dnnl_abc</a> or <a class="el" href="group__dnnl__api__memory.html#gga395e42b594683adb25ed2d842bb3091daf8537ed269eb5d0586456db114039c00" title="permuted 3D tensor ">dnnl_acb</a>   </td></tr>
</table>
<h3>Attributes and Post-ops</h3>
<p>Attributes and post-ops enable modifying the behavior of the MatMul primitive. The following attributes and post-ops are supported:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Type  </th><th class="markdownTableHeadLeft">Operation  </th><th class="markdownTableHeadLeft">Restrictions  </th><th class="markdownTableHeadLeft">Des   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Attribute  </td><td class="markdownTableBodyLeft"><a class="el" href="structdnnl_1_1primitive__attr.html#a4b81acc8e48886313154f75c1708ae02">Output scales</a>  </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">Scales the result by given scale factor(s)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Attribute  </td><td class="markdownTableBodyLeft"><a class="el" href="structdnnl_1_1primitive__attr.html#aee82deb014cf9702ceb3e725156c25a1">Zero points</a>  </td><td class="markdownTableBodyLeft">Int8 computations only  </td><td class="markdownTableBodyLeft">Sets zero point(s) for the corresponding tensors   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Post-op  </td><td class="markdownTableBodyLeft"><a class="el" href="structdnnl_1_1post__ops.html#a66606f08467b19091e696b52a2f789e6">Eltwise</a>  </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">Applies an <a class="el" href="group__dnnl__api__eltwise.html">Eltwise</a> operation to the result   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Post-op  </td><td class="markdownTableBodyLeft"><a class="el" href="structdnnl_1_1post__ops.html#a078ab8ec15423d2b3d26f3619a78ca38">Sum</a>  </td><td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft">Adds the operation result to the destination tensor instead of overwriting it   </td></tr>
</table>
<p>To facilitate dynamic quantization, the primitive supports run-time output scales. That means a user could configure attributes with output scales set to the <a class="el" href="group__dnnl__api__memory.html#gab16365c11b4dc88fbb453edb51f1979f" title="A wildcard value for floating point values that are unknown at a primitive creation time...">DNNL_RUNTIME_F32_VAL</a> wildcard value instead of the actual scales, if the scales are not known at the primitive descriptor creation stage. In this case, the user must provide the scales as an additional input memory object with argument <code>DNNL_ARG_ATTR_OUTPUT_SCALES</code> during the execution stage.</p>
<p>Similarly to run-time output scales, the primitive supports run-time zero points. The wildcard value for zero points is <a class="el" href="group__dnnl__api__memory.html#ga30139d5110e9e895ccd93fe503ca4c35" title="A wildcard value for int32_t values that are unknown at a primitive creation time. ">DNNL_RUNTIME_S32_VAL</a>. During the execution stage, the corresponding memory object needs to be passed in the argument with index set to (<code>DNNL_ARG_ATTR_ZERO_POINTS | DNNL_ARG_${MEMORY_INDEX}</code>).</p><ul>
<li>For instance, source tensor zero points memory argument would be passed with index (<code>DNNL_ARG_ATTR_ZERO_POINTS | DNNL_ARG_SRC</code>).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>Please check tutorials below to see run-time attributes in use.</dd></dl>
<h2>Implementation Limitations</h2>
<ol type="1">
<li>Check <a class="el" href="dev_guide_data_types.html">Data Types</a>.</li>
<li>The CPU engine doesn't support <code>u8</code> data type for weights.</li>
</ol>
<h2>Performance Tips</h2>
<ul>
<li>Use <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a> for either of the input tensors if and only if the shape of the corresponding tensor is fully known at creation time and it is possible to cache reordered tensors across multiple primitive executions. For instance, a good candidate for reuse are the weights tensors during inference: their shapes and data types are known in advance; thus they can be reordered during the first inference pass and can be reused during the subsequent passes. However, if any of the input tensors cannot be reused, it is best to force the primitive to use the same format as that used by the tensors.</li>
</ul>
<h2>Tutorials</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Engine  </th><th class="markdownTableHeadLeft">Name  </th><th class="markdownTableHeadLeft">Com   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CPU  </td><td class="markdownTableBodyLeft"><a class="el" href="cpu_sgemm_and_matmul_cpp.html">MatMul Tutorial: Comparison with SGEMM</a>  </td><td class="markdownTableBodyLeft"><p class="starttd">C++ API example demonstrating <a class="el" href="dev_guide_matmul.html">MatMul</a> as a replacement for SGEMM functions.</p>
<p class="endtd">Concepts:</p><ul>
<li>Create primitive once, use multiple times<ul>
<li>Run-time tensor shapes: <a class="el" href="group__dnnl__api__memory.html#gaa596c5a6102df77a550bad98f0d5cc12" title="A wildcard value for dimensions that are unknown at a primitive creation time. ">DNNL_RUNTIME_DIM_VAL</a></li>
<li>Run-time output scales: <a class="el" href="structdnnl_1_1primitive__attr.html#a4b81acc8e48886313154f75c1708ae02" title="Sets output scaling factors correspondence mask and values. ">dnnl::primitive_attr::set_output_scales()</a> and <a class="el" href="group__dnnl__api__memory.html#gab16365c11b4dc88fbb453edb51f1979f" title="A wildcard value for floating point values that are unknown at a primitive creation time...">DNNL_RUNTIME_F32_VAL</a>   </li>
</ul>
</li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">CPU/GPU  </td><td class="markdownTableBodyLeft"><a class="el" href="inference_int8_matmul_cpp.html">MatMul Tutorial: INT8 Inference</a>  </td><td class="markdownTableBodyLeft"><p class="starttd">C++ API example demonstrating how one can use <a class="el" href="dev_guide_matmul.html">MatMul</a> fused with ReLU in INT8 inference.</p>
<p class="endtd">Concepts:</p><ul>
<li>Asymmetric quantization<ul>
<li>Run-time output scales: <a class="el" href="structdnnl_1_1primitive__attr.html#a4b81acc8e48886313154f75c1708ae02" title="Sets output scaling factors correspondence mask and values. ">dnnl::primitive_attr::set_output_scales()</a> and <a class="el" href="group__dnnl__api__memory.html#gab16365c11b4dc88fbb453edb51f1979f" title="A wildcard value for floating point values that are unknown at a primitive creation time...">DNNL_RUNTIME_F32_VAL</a></li>
<li>Run-time zero points: <a class="el" href="structdnnl_1_1primitive__attr.html#aee82deb014cf9702ceb3e725156c25a1" title="Sets zero points for primitive operations for a given memory argument. ">dnnl::primitive_attr::set_zero_points()</a> and <a class="el" href="group__dnnl__api__memory.html#ga30139d5110e9e895ccd93fe503ca4c35" title="A wildcard value for int32_t values that are unknown at a primitive creation time. ">DNNL_RUNTIME_S32_VAL</a></li>
</ul>
</li>
<li><a class="el" href="dev_guide_attributes_post_ops.html">Operation fusion</a></li>
<li>Create primitive once, use multiple times<ul>
<li>Run-time tensor shapes: <a class="el" href="group__dnnl__api__memory.html#gaa596c5a6102df77a550bad98f0d5cc12" title="A wildcard value for dimensions that are unknown at a primitive creation time. ">DNNL_RUNTIME_DIM_VAL</a></li>
</ul>
</li>
<li>Weights pre-packing: use <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa100b8cad7cf2a56f6df78f171f97a1ec" title="Placeholder memory format tag. ">dnnl::memory::format_tag::any</a>   </li>
</ul>
</td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CPU  </td><td class="markdownTableBodyLeft"><a class="el" href="cpu_matmul_quantization_cpp.html">MatMul Tutorial: Quantization</a>  </td><td class="markdownTableBodyLeft"><p class="starttd">C++ API example demonstrating how one can perform reduced precision matrix-matrix multiplication using <a class="el" href="dev_guide_matmul.html">MatMul</a> and the accuracy of the result compared to the floating point computations.</p>
<p class="endtd">Concepts:</p><ul>
<li><b>Static</b> and <b>dynamic</b> quantization</li>
<li>Asymmetric quantization<ul>
<li>Run-time output scales: <a class="el" href="structdnnl_1_1primitive__attr.html#a4b81acc8e48886313154f75c1708ae02" title="Sets output scaling factors correspondence mask and values. ">dnnl::primitive_attr::set_output_scales()</a> and <a class="el" href="group__dnnl__api__memory.html#gab16365c11b4dc88fbb453edb51f1979f" title="A wildcard value for floating point values that are unknown at a primitive creation time...">DNNL_RUNTIME_F32_VAL</a></li>
<li>Run-time zero points: <a class="el" href="structdnnl_1_1primitive__attr.html#aee82deb014cf9702ceb3e725156c25a1" title="Sets zero points for primitive operations for a given memory argument. ">dnnl::primitive_attr::set_zero_points()</a> and <a class="el" href="group__dnnl__api__memory.html#ga30139d5110e9e895ccd93fe503ca4c35" title="A wildcard value for int32_t values that are unknown at a primitive creation time. ">DNNL_RUNTIME_S32_VAL</a>   </li>
</ul>
</li>
</ul>
</td></tr>
</table>
</div></div><!-- contents -->
<div class="footer">
    <div class="footer-wrapper">
        <ul id="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>