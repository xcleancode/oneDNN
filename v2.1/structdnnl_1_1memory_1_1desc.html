<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>oneDNN: dnnl::memory::desc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneAPI Deep Neural Network Library (oneDNN)</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneAPI Deep Neural Network Library (oneDNN)</div>
    </a>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
   <div id="projectnumber">2.1.3</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdnnl_1_1memory_1_1desc.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structdnnl_1_1memory_1_1desc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dnnl::memory::desc Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A memory descriptor.  
 <a href="structdnnl_1_1memory_1_1desc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="oneapi_2dnnl_2dnnl_8hpp_source.html">dnnl.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dnnl::memory::desc:</div>
<div class="dyncontent">
<div class="center"><img src="structdnnl_1_1memory_1_1desc__coll__graph.png" border="0" usemap="#dnnl_1_1memory_1_1desc_coll__map" alt="Collaboration graph"/></div>
<map name="dnnl_1_1memory_1_1desc_coll__map" id="dnnl_1_1memory_1_1desc_coll__map">
<area shape="rect" id="node2" href="structdnnl__memory__desc__t.html" title="Memory descriptor. " alt="" coords="373,81,535,108"/>
<area shape="rect" id="node3" href="structdnnl__wino__desc__t.html" title="Description of tensor of weights for winograd 2x3 convolution. " alt="" coords="38,5,175,32"/>
<area shape="rect" id="node4" href="structdnnl__blocking__desc__t.html" title="Generic description of blocked data layout for most memory formats. " alt="" coords="26,56,187,83"/>
<area shape="rect" id="node5" href="structdnnl__rnn__packed__desc__t.html" title="Description of tensor of packed weights for rnn. " alt="" coords="16,107,197,133"/>
<area shape="rect" id="node6" href="structdnnl__memory__extra__desc__t.html" title="Description of extra information stored in memory. " alt="" coords="5,157,208,184"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a12f9b43aae8c214d695b321b543b5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a2a12f9b43aae8c214d695b321b543b5c">desc</a> ()</td></tr>
<tr class="memdesc:a2a12f9b43aae8c214d695b321b543b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a zero (empty) memory descriptor.  <a href="#a2a12f9b43aae8c214d695b321b543b5c">More...</a><br /></td></tr>
<tr class="separator:a2a12f9b43aae8c214d695b321b543b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f068d5a2e5b2d043d2f203717a0ceb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a03f068d5a2e5b2d043d2f203717a0ceb">desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;adims, <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a> adata_type, <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">format_tag</a> aformat_tag, bool allow_empty=false)</td></tr>
<tr class="memdesc:a03f068d5a2e5b2d043d2f203717a0ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor.  <a href="#a03f068d5a2e5b2d043d2f203717a0ceb">More...</a><br /></td></tr>
<tr class="separator:a03f068d5a2e5b2d043d2f203717a0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0471538db2d230492a07356929c859c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#ac0471538db2d230492a07356929c859c">desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;adims, <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a> adata_type, const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;strides, bool allow_empty=false)</td></tr>
<tr class="memdesc:ac0471538db2d230492a07356929c859c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by strides.  <a href="#ac0471538db2d230492a07356929c859c">More...</a><br /></td></tr>
<tr class="separator:ac0471538db2d230492a07356929c859c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#adc5a3eb4dbd8aef650bf6823f13167e3">desc</a> (const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> &amp;<a class="el" href="structdnnl_1_1memory_1_1desc.html#afea646e8777c2341509a61f4ae17dcf3">data</a>)</td></tr>
<tr class="memdesc:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor from a C API data structure.  <a href="#adc5a3eb4dbd8aef650bf6823f13167e3">More...</a><br /></td></tr>
<tr class="separator:adc5a3eb4dbd8aef650bf6823f13167e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de2abef3b34e94c5dfa16e1fc3f3aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a7de2abef3b34e94c5dfa16e1fc3f3aab">submemory_desc</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;adims, const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;offsets, bool allow_empty=false) const</td></tr>
<tr class="memdesc:a7de2abef3b34e94c5dfa16e1fc3f3aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor for a region inside an area described by this memory descriptor.  <a href="#a7de2abef3b34e94c5dfa16e1fc3f3aab">More...</a><br /></td></tr>
<tr class="separator:a7de2abef3b34e94c5dfa16e1fc3f3aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95a6fbd16dd8b7c421611d39d49fe3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#ab95a6fbd16dd8b7c421611d39d49fe3f">reshape</a> (const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;adims, bool allow_empty=false) const</td></tr>
<tr class="memdesc:ab95a6fbd16dd8b7c421611d39d49fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by reshaping an existing one.  <a href="#ab95a6fbd16dd8b7c421611d39d49fe3f">More...</a><br /></td></tr>
<tr class="separator:ab95a6fbd16dd8b7c421611d39d49fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e831b990a91d61bc44e57f6e895a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a70e831b990a91d61bc44e57f6e895a83">permute_axes</a> (const std::vector&lt; int &gt; &amp;permutation, bool allow_empty=false) const</td></tr>
<tr class="memdesc:a70e831b990a91d61bc44e57f6e895a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a memory descriptor by permuting axes in an existing one.  <a href="#a70e831b990a91d61bc44e57f6e895a83">More...</a><br /></td></tr>
<tr class="separator:a70e831b990a91d61bc44e57f6e895a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf95c174b7d7f5ea59646886719d0a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#aaf95c174b7d7f5ea59646886719d0a2b">dims</a> () const</td></tr>
<tr class="memdesc:aaf95c174b7d7f5ea59646886719d0a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dimensions of the memory descriptor.  <a href="#aaf95c174b7d7f5ea59646886719d0a2b">More...</a><br /></td></tr>
<tr class="separator:aaf95c174b7d7f5ea59646886719d0a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cb5e5f28d660a0105eb7580e5ab213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">memory::data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#ab3cb5e5f28d660a0105eb7580e5ab213">data_type</a> () const</td></tr>
<tr class="memdesc:ab3cb5e5f28d660a0105eb7580e5ab213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data type of the memory descriptor.  <a href="#ab3cb5e5f28d660a0105eb7580e5ab213">More...</a><br /></td></tr>
<tr class="separator:ab3cb5e5f28d660a0105eb7580e5ab213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20108bc192912382aa4a95ae27df804"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#ac20108bc192912382aa4a95ae27df804">get_size</a> () const</td></tr>
<tr class="memdesc:ac20108bc192912382aa4a95ae27df804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of the memory descriptor in bytes.  <a href="#ac20108bc192912382aa4a95ae27df804">More...</a><br /></td></tr>
<tr class="separator:ac20108bc192912382aa4a95ae27df804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa162a1ba5621a799c8a909c726f021a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#aa162a1ba5621a799c8a909c726f021a2">is_zero</a> () const</td></tr>
<tr class="memdesc:aa162a1ba5621a799c8a909c726f021a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the memory descriptor is zero (empty).  <a href="#aa162a1ba5621a799c8a909c726f021a2">More...</a><br /></td></tr>
<tr class="separator:aa162a1ba5621a799c8a909c726f021a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d623dab6f8a8ebc34b0da95814e3728"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a9d623dab6f8a8ebc34b0da95814e3728">operator==</a> (const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;other) const</td></tr>
<tr class="memdesc:a9d623dab6f8a8ebc34b0da95814e3728"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equality operator.  <a href="#a9d623dab6f8a8ebc34b0da95814e3728">More...</a><br /></td></tr>
<tr class="separator:a9d623dab6f8a8ebc34b0da95814e3728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1bc8d3b88a2c304fd9535ea45fbb72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#a5a1bc8d3b88a2c304fd9535ea45fbb72">operator!=</a> (const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;other) const</td></tr>
<tr class="memdesc:a5a1bc8d3b88a2c304fd9535ea45fbb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inequality operator.  <a href="#a5a1bc8d3b88a2c304fd9535ea45fbb72">More...</a><br /></td></tr>
<tr class="separator:a5a1bc8d3b88a2c304fd9535ea45fbb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf628c4bec9060fa2e779ca148a32956"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#adf628c4bec9060fa2e779ca148a32956">operator bool</a> () const</td></tr>
<tr class="memdesc:adf628c4bec9060fa2e779ca148a32956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the object is not empty.  <a href="#adf628c4bec9060fa2e779ca148a32956">More...</a><br /></td></tr>
<tr class="separator:adf628c4bec9060fa2e779ca148a32956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afea646e8777c2341509a61f4ae17dcf3"><td class="memItemLeft" align="right" valign="top"><a id="afea646e8777c2341509a61f4ae17dcf3"></a>
<a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdnnl_1_1memory_1_1desc.html#afea646e8777c2341509a61f4ae17dcf3">data</a></td></tr>
<tr class="memdesc:afea646e8777c2341509a61f4ae17dcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C API data structure. <br /></td></tr>
<tr class="separator:afea646e8777c2341509a61f4ae17dcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A memory descriptor. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="batch_normalization_8cpp-example.html#_a4">batch_normalization.cpp</a>, <a class="el" href="binary_8cpp-example.html#_a4">binary.cpp</a>, <a class="el" href="bnorm_u8_via_binary_postops_8cpp-example.html#_a4">bnorm_u8_via_binary_postops.cpp</a>, <a class="el" href="cnn_inference_f32_8cpp-example.html#_a5">cnn_inference_f32.cpp</a>, <a class="el" href="cnn_inference_int8_8cpp-example.html#_a5">cnn_inference_int8.cpp</a>, <a class="el" href="cnn_training_bf16_8cpp-example.html#_a5">cnn_training_bf16.cpp</a>, <a class="el" href="cnn_training_f32_8cpp-example.html#_a5">cnn_training_f32.cpp</a>, <a class="el" href="concat_8cpp-example.html#_a4">concat.cpp</a>, <a class="el" href="convolution_8cpp-example.html#_a5">convolution.cpp</a>, <a class="el" href="cpu_matmul_quantization_8cpp-example.html#_a5">cpu_matmul_quantization.cpp</a>, <a class="el" href="cpu_rnn_inference_f32_8cpp-example.html#_a5">cpu_rnn_inference_f32.cpp</a>, <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html#_a6">cpu_rnn_inference_int8.cpp</a>, <a class="el" href="cpu_sgemm_and_matmul_8cpp-example.html#_a4">cpu_sgemm_and_matmul.cpp</a>, <a class="el" href="eltwise_8cpp-example.html#_a4">eltwise.cpp</a>, <a class="el" href="getting_started_8cpp-example.html#_a2">getting_started.cpp</a>, <a class="el" href="gpu_opencl_interop_8cpp-example.html#_a3">gpu_opencl_interop.cpp</a>, <a class="el" href="inference_int8_matmul_8cpp-example.html#_a3">inference_int8_matmul.cpp</a>, <a class="el" href="inner_product_8cpp-example.html#_a4">inner_product.cpp</a>, <a class="el" href="layer_normalization_8cpp-example.html#_a4">layer_normalization.cpp</a>, <a class="el" href="logsoftmax_8cpp-example.html#_a4">logsoftmax.cpp</a>, <a class="el" href="lrn_8cpp-example.html#_a4">lrn.cpp</a>, <a class="el" href="lstm_8cpp-example.html#_a4">lstm.cpp</a>, <a class="el" href="matmul_8cpp-example.html#_a4">matmul.cpp</a>, <a class="el" href="memory_format_propagation_8cpp-example.html#_a2">memory_format_propagation.cpp</a>, <a class="el" href="performance_profiling_8cpp-example.html#_a16">performance_profiling.cpp</a>, <a class="el" href="pooling_8cpp-example.html#_a4">pooling.cpp</a>, <a class="el" href="prelu_8cpp-example.html#_a5">prelu.cpp</a>, <a class="el" href="reduction_8cpp-example.html#_a4">reduction.cpp</a>, <a class="el" href="reorder_8cpp-example.html#_a4">reorder.cpp</a>, <a class="el" href="resampling_8cpp-example.html#_a4">resampling.cpp</a>, <a class="el" href="rnn_training_f32_8cpp-example.html#_a7">rnn_training_f32.cpp</a>, <a class="el" href="shuffle_8cpp-example.html#_a4">shuffle.cpp</a>, <a class="el" href="softmax_8cpp-example.html#_a4">softmax.cpp</a>, <a class="el" href="sum_8cpp-example.html#_a4">sum.cpp</a>, and <a class="el" href="sycl_interop_buffer_8cpp-example.html#_a2">sycl_interop_buffer.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2a12f9b43aae8c214d695b321b543b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12f9b43aae8c214d695b321b543b5c">&#9670;&nbsp;</a></span>desc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a zero (empty) memory descriptor. </p>
<p>Such a memory descriptor can be used to indicate absence of an argument. </p>

</div>
</div>
<a id="a03f068d5a2e5b2d043d2f203717a0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f068d5a2e5b2d043d2f203717a0ceb">&#9670;&nbsp;</a></span>desc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>adims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>&#160;</td>
          <td class="paramname"><em>adata_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">format_tag</a>&#160;</td>
          <td class="paramname"><em>aformat_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor. </p>
<dl class="section note"><dt>Note</dt><dd>The logical order of dimensions corresponds to the <code>abc...</code> format tag, and the physical meaning of the dimensions depends both on the primitive that would operate on this memory and the operation context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adims</td><td>Tensor dimensions. </td></tr>
    <tr><td class="paramname">adata_type</td><td>Data precision/type. </td></tr>
    <tr><td class="paramname">aformat_tag</td><td>Memory format tag. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be constructed. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0471538db2d230492a07356929c859c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0471538db2d230492a07356929c859c">&#9670;&nbsp;</a></span>desc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>adims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">data_type</a>&#160;</td>
          <td class="paramname"><em>adata_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by strides. </p>
<dl class="section note"><dt>Note</dt><dd>The logical order of dimensions corresponds to the <code>abc...</code> format tag, and the physical meaning of the dimensions depends both on the primitive that would operate on this memory and the operation context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adims</td><td>Tensor dimensions. </td></tr>
    <tr><td class="paramname">adata_type</td><td>Data precision/type. </td></tr>
    <tr><td class="paramname">strides</td><td>Strides for each dimension. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be constructed. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5a3eb4dbd8aef650bf6823f13167e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5a3eb4dbd8aef650bf6823f13167e3">&#9670;&nbsp;</a></span>desc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl__memory__desc__t.html">dnnl_memory_desc_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor from a C API data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A C API <a class="el" href="structdnnl__memory__desc__t.html" title="Memory descriptor. ">dnnl_memory_desc_t</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7de2abef3b34e94c5dfa16e1fc3f3aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de2abef3b34e94c5dfa16e1fc3f3aab">&#9670;&nbsp;</a></span>submemory_desc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::submemory_desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>adims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor for a region inside an area described by this memory descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adims</td><td>Sizes of the region. </td></tr>
    <tr><td class="paramname">offsets</td><td>Offsets to the region from the encompassing memory object in each dimension. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A memory descriptor for the region. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cpu_rnn_inference_f32_8cpp-example.html#a27">cpu_rnn_inference_f32.cpp</a>, <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html#a42">cpu_rnn_inference_int8.cpp</a>, and <a class="el" href="rnn_training_f32_8cpp-example.html#a13">rnn_training_f32.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab95a6fbd16dd8b7c421611d39d49fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95a6fbd16dd8b7c421611d39d49fe3f">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">dims</a> &amp;&#160;</td>
          <td class="paramname"><em>adims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by reshaping an existing one. </p>
<p>The new memory descriptor inherits the data type. This operation is valid only for memory descriptors that have format_kind set to <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa61326117ed4a9ddf3f754e71e119e5b3" title="A tensor in a generic format described by the stride and blocking values in each dimension. ">dnnl::memory::format_kind::blocked</a> or <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa100b8cad7cf2a56f6df78f171f97a1ec" title="Unspecified format kind. ">dnnl::memory::format_kind::any</a>.</p>
<p>The operation ensures that the transformation of the physical memory format corresponds to the transformation of the logical dimensions. If such transformation is impossible, the function either throws an exception (default) or returns a zero memory descriptor depending on the <code>allow_empty</code> flag.</p>
<p>The reshape operation can be described as a combination of the following basic operations:</p><ol type="1">
<li>Add a dimension of size <code>1</code>. This is always possible.</li>
<li>Remove a dimension of size <code>1</code>. This is possible only if the dimension has no padding (i.e. <code>padded_dims[dim] == dims[dim] &amp;&amp; dims[dim] == 1</code>).</li>
<li>Split a dimension into multiple ones. This is possible only if the product of all tensor dimensions stays constant and the dimension being split does not have padding (i.e. <code>padded_dims[dim] = dims[dim]</code>).</li>
<li>Join multiple consecutive dimensions into a single one. As in the cases above, this requires that the dimensions do not have padding and that the memory format is such that in physical memory these dimensions are dense and have the same order as their logical counterparts. This also assumes that these dimensions are not blocked.<ul>
<li>Here, 'dense' means: <code>stride for dim[i] == (stride for dim[i + 1]) * dim[i + 1]</code>;</li>
<li>And 'same order' means: <code>i &lt; j</code> if and only if <code>stride for dim[j] &lt;= stride for dim[i]</code>.</li>
</ul>
</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Some combinations of physical memory layout and/or offsets or dimensions may result in a failure to make a reshape.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adims</td><td>New dimensions. The product of dimensions must remain constant. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new memory descriptor with new dimensions. </dd></dl>

</div>
</div>
<a id="a70e831b990a91d61bc44e57f6e895a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e831b990a91d61bc44e57f6e895a83">&#9670;&nbsp;</a></span>permute_axes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> dnnl::memory::desc::permute_axes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a memory descriptor by permuting axes in an existing one. </p>
<p>The physical memory layout representation is adjusted accordingly to maintain the consistency between the logical and physical parts of the memory descriptor. The new memory descriptor inherits the data type.</p>
<p>The new memory descriptor inherits the data type. This operation is valid only for memory descriptors that have format_kind set to <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa61326117ed4a9ddf3f754e71e119e5b3" title="A tensor in a generic format described by the stride and blocking values in each dimension. ">dnnl::memory::format_kind::blocked</a> or <a class="el" href="structdnnl_1_1memory.html#aabcadfb0e23a36a91272fc571cff105fa100b8cad7cf2a56f6df78f171f97a1ec" title="Unspecified format kind. ">dnnl::memory::format_kind::any</a>.</p>
<p>The logical axes will be permuted in the following manner: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; ndims(); i++)</div><div class="line">    new_desc.dims()[permutation[i]] = <a class="code" href="structdnnl_1_1memory_1_1desc.html#aaf95c174b7d7f5ea59646886719d0a2b">dims</a>()[i];</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line">std::vector&lt;int&gt; permutation = {1, 0}; <span class="comment">// swap the first and</span></div><div class="line">                                       <span class="comment">// the second axes</span></div><div class="line"><a class="code" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a> in_md(</div><div class="line">        {2, 3}, <a class="code" href="structdnnl_1_1memory_1_1desc.html#ab3cb5e5f28d660a0105eb7580e5ab213">data_type</a>, <a class="code" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa187ef4436122d1cc2f40dc2b92f0eba0">memory::format_tag::ab</a>);</div><div class="line"><a class="code" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a> expect_out_md(</div><div class="line">        {3, 2}, <a class="code" href="structdnnl_1_1memory_1_1desc.html#ab3cb5e5f28d660a0105eb7580e5ab213">data_type</a>, <a class="code" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3fa07159c47ee1b19ae4fb9c40d480856c4">memory::format_tag::ba</a>);</div><div class="line"></div><div class="line">assert(in_md.permute_axes(permutation) == expect_out_md);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutation</td><td>Axes permutation. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>A flag signifying whether construction is allowed to fail without throwing an exception. In this case a zero memory descriptor will be returned. This flag is optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new memory descriptor with new dimensions. </dd></dl>

</div>
</div>
<a id="aaf95c174b7d7f5ea59646886719d0a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf95c174b7d7f5ea59646886719d0a2b">&#9670;&nbsp;</a></span>dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory.html#afdd20764d58c0b517d5a31276672aeb8">memory::dims</a> dnnl::memory::desc::dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns dimensions of the memory descriptor. </p>
<p>Potentially expensive due to the data copy involved. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the dimensions vector. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inference_int8_matmul_8cpp-example.html#a19">inference_int8_matmul.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab3cb5e5f28d660a0105eb7580e5ab213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cb5e5f28d660a0105eb7580e5ab213">&#9670;&nbsp;</a></span>data_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">memory::data_type</a> dnnl::memory::desc::data_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data type of the memory descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>The data type. </dd></dl>

</div>
</div>
<a id="ac20108bc192912382aa4a95ae27df804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20108bc192912382aa4a95ae27df804">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t dnnl::memory::desc::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of the memory descriptor in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes required to allocate a memory buffer for the memory object described by this memory descriptor including the padding area. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cpu_rnn_inference_f32_8cpp-example.html#a34">cpu_rnn_inference_f32.cpp</a>, <a class="el" href="cpu_rnn_inference_int8_8cpp-example.html#a49">cpu_rnn_inference_int8.cpp</a>, and <a class="el" href="performance_profiling_8cpp-example.html#a2">performance_profiling.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aa162a1ba5621a799c8a909c726f021a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa162a1ba5621a799c8a909c726f021a2">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the memory descriptor is zero (empty). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the memory descriptor describes an empty memory and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9d623dab6f8a8ebc34b0da95814e3728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d623dab6f8a8ebc34b0da95814e3728">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another memory descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and the other memory descriptors have the same format tag, dimensions, strides, blocking, etc. </dd></dl>

</div>
</div>
<a id="a5a1bc8d3b88a2c304fd9535ea45fbb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1bc8d3b88a2c304fd9535ea45fbb72">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dnnl::memory::desc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdnnl_1_1memory_1_1desc.html">desc</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another memory descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and the other memory descriptors describe different memory. </dd></dl>

</div>
</div>
<a id="adf628c4bec9060fa2e779ca148a32956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf628c4bec9060fa2e779ca148a32956">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dnnl::memory::desc::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the object is not empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the object is not empty. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/oneapi/dnnl/<a class="el" href="oneapi_2dnnl_2dnnl_8hpp_source.html">dnnl.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
    <script>
        $('#top').prependTo($('#side-nav'));
    </script>
    <div class="footer-wrapper">
        <hr>
        <ul class="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>