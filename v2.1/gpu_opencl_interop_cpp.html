<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>oneDNN: Getting started on GPU with OpenCL extensions API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneAPI Deep Neural Network Library (oneDNN)</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneAPI Deep Neural Network Library (oneDNN)</div>
    </a>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
   <div id="projectnumber">2.1.3</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('gpu_opencl_interop_cpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting started on GPU with OpenCL extensions API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>This C++ API example demonstrates programming for Intel(R) Processor Graphics with OpenCL* extensions API in oneDNN.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="gpu_opencl_interop_8cpp-example.html">gpu_opencl_interop.cpp</a> </p>
</blockquote>
<p>The workflow includes following steps:</p><ul>
<li>Create a GPU engine. It uses OpenCL as the runtime in this sample.</li>
<li>Create a GPU memory descriptor/object.</li>
<li>Create an OpenCL kernel for GPU data initialization</li>
<li>Access a GPU memory via OpenCL interoperability interface</li>
<li>Access a GPU command queue via OpenCL interoperability interface</li>
<li>Execute a OpenCL kernel with related GPU command queue and GPU memory</li>
<li>Create operation descriptor/operation primitives descriptor/primitive .</li>
<li>Execute the primitive with the initialized GPU memory</li>
<li>Validate the result by mapping the OpenCL memory via OpenCL interoperability interface</li>
</ul>
<h1><a class="anchor" id="gpu_opencl_interop_cpp_headers"></a>
Public headers</h1>
<p>To start using oneDNN, we must first include the <a class="el" href="oneapi_2dnnl_2dnnl_8hpp.html">dnnl.hpp</a> header file in the application. We also include CL/cl.h for using OpenCL APIs and <a class="el" href="oneapi_2dnnl_2dnnl__debug_8h.html">dnnl_debug.h</a>, which contains some debugging facilities such as returning a string representation for common oneDNN C types. All C++ API types and functions reside in the <code>dnnl</code> namespace. For simplicity of the example we import this namespace.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CL/cl.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="oneapi_2dnnl_2dnnl_8hpp.html">oneapi/dnnl/dnnl.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;oneapi/dnnl/dnnl_ocl.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;example_utils.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacednnl.html">dnnl</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div></div><!-- fragment --> <h1><a class="anchor" id="gpu_opencl_interop_cpp_tutorial"></a>
gpu_opencl_interop_tutorial() function</h1>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub1"></a>
Engine and stream</h2>
<p>All oneDNN primitives and memory objects are attached to a particular <a class="el" href="structdnnl_1_1engine.html">dnnl::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device to which they are attached, and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create engines, we must specify the <a class="el" href="structdnnl_1_1engine.html#a2635da16314dcbdb9bd9ea431316bb1a">dnnl::engine::kind</a> and the index of the device of the given kind. In this example we use the first available GPU engine, so the index for the engine is 0. This example assumes OpenCL being a runtime for GPU. In such case, during engine creation, an OpenCL context is also created and attaches to the created engine.</p>
<div class="fragment"><div class="line">    <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a> eng(engine::kind::gpu, 0);</div></div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structdnnl_1_1stream.html">dnnl::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>In this example, a GPU stream is created. This example assumes OpenCL being a runtime for GPU. During stream creation, an OpenCL command queue is also created and attaches to this stream.</p>
<div class="fragment"><div class="line">    <a class="code" href="structdnnl_1_1stream.html">dnnl::stream</a> strm(eng);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub2"></a>
Wrapping data into oneDNN memory object</h2>
<p>Next, we create a memory object. We need to specify dimensions of our memory by passing a memory::dims object. Then we create a memory descriptor with these dimensions, with the <a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dcea512dc597be7ae761876315165dc8bd2e" title="32-bit/single-precision floating point. ">dnnl::memory::data_type::f32</a> data type, and with the <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3faded7ac40158367123c5467281d44cbeb" title="4D CNN activations tensor; an alias for dnnl::memory::format_tag::abcd ">dnnl::memory::format_tag::nchw</a> memory format. Finally, we construct a memory object and pass the memory descriptor. The library allocates memory internally. </p><div class="fragment"><div class="line">    memory::dims tz_dims = {2, 3, 4, 5};</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> N = std::accumulate(tz_dims.begin(), tz_dims.end(), (size_t)1,</div><div class="line">            std::multiplies&lt;size_t&gt;());</div><div class="line"></div><div class="line">    memory::desc mem_d(</div><div class="line">            tz_dims, memory::data_type::f32, memory::format_tag::nchw);</div><div class="line"></div><div class="line">    memory mem(mem_d, eng);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub3"></a>
Initialize the data by executing a custom OpenCL kernel</h2>
<p>We are going to create an OpenCL kernel that will initialize our data. It requires writing a bit of C code to create an OpenCL program from a string literal source. The kernel initializes the data by the 0, -1, 2, -3, ... sequence: <code>data[i] = (-1)^i * i</code>. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *ocl_code</div><div class="line">            = <span class="stringliteral">&quot;__kernel void init(__global float *data) {&quot;</span></div><div class="line">              <span class="stringliteral">&quot;    int id = get_global_id(0);&quot;</span></div><div class="line">              <span class="stringliteral">&quot;    data[id] = (id % 2) ? -id : id;&quot;</span></div><div class="line">              <span class="stringliteral">&quot;}&quot;</span>;</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
 Create/Build Opencl kernel by <code>create_init_opencl_kernel()</code> function. Refer to the full code example for the <code>create_init_opencl_kernel()</code> function. </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name = <span class="stringliteral">&quot;init&quot;</span>;</div><div class="line">    cl_kernel ocl_init_kernel = create_init_opencl_kernel(</div><div class="line">            ocl_interop::get_context(eng), kernel_name, ocl_code);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
 The next step is to execute our OpenCL kernel by setting its arguments and enqueueing to an OpenCL queue. You can extract the underlying OpenCL buffer from the memory object using the interoperability interface: dnnl::memory::get_ocl_mem_object() . For simplicity we can just construct a stream, extract the underlying OpenCL queue, and enqueue the kernel to this queue. </p><div class="fragment"><div class="line">    cl_mem ocl_buf = ocl_interop::get_mem_object(mem);</div><div class="line">    OCL_CHECK(clSetKernelArg(ocl_init_kernel, 0, <span class="keyword">sizeof</span>(ocl_buf), &amp;ocl_buf));</div><div class="line"></div><div class="line">    cl_command_queue ocl_queue = ocl_interop::get_command_queue(strm);</div><div class="line">    OCL_CHECK(clEnqueueNDRangeKernel(ocl_queue, ocl_init_kernel, 1, <span class="keyword">nullptr</span>, &amp;N,</div><div class="line">            <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>));</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub4"></a>
Create and execute a primitive</h2>
<p>There are three steps to create an operation primitive in oneDNN:</p><ol type="1">
<li>Create an operation descriptor.</li>
<li>Create a primitive descriptor.</li>
<li>Create a primitive.</li>
</ol>
<p>Let's create the primitive to perform the ReLU (rectified linear unit) operation: x = max(0, x). An operation descriptor has no dependency on a specific engine - it just describes some operation. On the contrary, primitive descriptors are attached to a specific engine and represent some implementation for this engine. A primitive object is a realization of a primitive descriptor, and its construction is usually much "heavier". </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(</div><div class="line">            prop_kind::forward, algorithm::eltwise_relu, mem_d, 0.0f);</div><div class="line">    <span class="keyword">auto</span> relu_pd = eltwise_forward::primitive_desc(relu_d, eng);</div><div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd);</div></div><!-- fragment --><p><br />
<br />
<br />
 Next, execute the primitive. </p><div class="fragment"><div class="line">    relu.execute(strm, {{<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, mem}, {<a class="code" href="group__dnnl__api__primitives__common.html#ga3ca217e4a06d42a0ede3c018383c388f">DNNL_ARG_DST</a>, mem}});</div><div class="line">    strm.wait();</div></div><!-- fragment --><p><br />
<br />
</p>
<dl class="section note"><dt>Note</dt><dd>Our primitive mem serves as both input and output parameter.</dd>
<dd>
Primitive submission on GPU is asynchronous; However, the user can call dnnl:stream::wait() to synchronize the stream and ensure that all previously submitted primitives are completed.</dd></dl>
<p><br />
</p>
<h2><a class="anchor" id="gpu_opencl_interop_cpp_sub5"></a>
Validate the results</h2>
<p>Before running validation codes, we need to copy the OpenCL memory to the host. This can be done using OpenCL API. For convenience, we use a utility function read_from_dnnl_memory() implementing required OpenCL API calls. After we read the data to the host, we can run validation codes on the host accordingly. </p><div class="fragment"><div class="line">    std::vector&lt;float&gt; mem_data(N);</div><div class="line">    read_from_dnnl_memory(mem_data.data(), mem);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; i++) {</div><div class="line">        <span class="keywordtype">float</span> expected = (i % 2) ? 0.0f : (<span class="keywordtype">float</span>)i;</div><div class="line">        <span class="keywordflow">if</span> (mem_data[i] != expected) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Expect &quot;</span> &lt;&lt; expected &lt;&lt; <span class="stringliteral">&quot; but got &quot;</span> &lt;&lt; mem_data[i]</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;Accuracy check failed.&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and running the example, the output should be just:</p>
<div class="fragment"><div class="line">Example passed.</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
    <script>
        $('#top').prependTo($('#side-nav'));
    </script>
    <div class="footer-wrapper">
        <hr>
        <ul class="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>