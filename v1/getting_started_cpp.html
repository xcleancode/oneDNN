<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>oneDNN: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script src="assets/mathjax/MathJax.js?config=TeX-AMS_CHTML,dnnl"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/dnn.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneAPI Deep Neural Network Library (oneDNN)</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneAPI Deep Neural Network Library (oneDNN)</div>
    </a>
   </div>
   <div id="projectbrief">Performance library for Deep Learning</div>
   <div id="projectnumber">1.8.0</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('getting_started_cpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b></b></p>
<p>This C++ API example demonstrates the basics of the oneDNN programming model.</p>
<blockquote class="doxtable">
<p>Example code: <a class="el" href="getting_started_8cpp-example.html">getting_started.cpp</a> </p>
</blockquote>
<p>This C++ API example demonstrates the basics of the oneDNN programming model:</p><ul>
<li>How to create oneDNN memory objects.<ul>
<li>How to get data from the user's buffer into a oneDNN memory object.</li>
<li>How a tensor's logical dimensions and memory object formats relate.</li>
</ul>
</li>
<li>How to create oneDNN primitives.</li>
<li>How to execute the primitives.</li>
</ul>
<p>The example uses the ReLU operation and comprises the following steps:</p><ol type="1">
<li>Creating <a class="el" href="getting_started_cpp.html#getting_started_cpp_sub1">Engine and stream</a> to execute a primitive.</li>
<li>Performing <a class="el" href="getting_started_cpp.html#getting_started_cpp_sub2">Data preparation (code outside of oneDNN)</a>.</li>
<li><a class="el" href="getting_started_cpp.html#getting_started_cpp_sub3">Wrapping data into a oneDNN memory object</a> (using different flavors).</li>
<li><a class="el" href="getting_started_cpp.html#getting_started_cpp_sub4">Creating a ReLU primitive</a>.</li>
<li><a class="el" href="getting_started_cpp.html#getting_started_cpp_sub5">Executing the ReLU primitive</a>.</li>
<li><a class="el" href="getting_started_cpp.html#getting_started_cpp_sub6">Obtaining the result and validation</a> (checking that the resulting image does not contain negative values).</li>
</ol>
<p>These steps are implemented in the <a class="el" href="getting_started_cpp.html#getting_started_cpp_tutorial">getting_started_tutorial() function</a>, which in turn is called from <a class="el" href="getting_started_cpp.html#getting_started_cpp_main">main() function</a> (which is also responsible for error handling).</p>
<h1><a class="anchor" id="getting_started_cpp_headers"></a>
Public headers</h1>
<p>To start using oneDNN we must first include the <a class="el" href="dnnl_8hpp.html">dnnl.hpp</a> header file in the program. We also include <a class="el" href="dnnl__debug_8h.html">dnnl_debug.h</a> in <a class="el" href="example__utils_8hpp_source.html">example_utils.hpp</a>, which contains some debugging facilities like returning a string representation for common oneDNN C types.</p>
<h1><a class="anchor" id="getting_started_cpp_tutorial"></a>
getting_started_tutorial() function</h1>
<h2><a class="anchor" id="getting_started_cpp_sub1"></a>
Engine and stream</h2>
<p>All oneDNN primitives and memory objects are attached to a particular <a class="el" href="structdnnl_1_1engine.html">dnnl::engine</a>, which is an abstraction of a computational device (see also <a class="el" href="dev_guide_basic_concepts.html">Basic Concepts</a>). The primitives are created and optimized for the device they are attached to and the memory objects refer to memory residing on the corresponding device. In particular, that means neither memory objects nor primitives that were created for one engine can be used on another.</p>
<p>To create an engine, we should specify the <a class="el" href="structdnnl_1_1engine.html#a2635da16314dcbdb9bd9ea431316bb1a">dnnl::engine::kind</a> and the index of the device of the given kind.</p>
<div class="fragment"><div class="line">    <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1aad1943a9fd6d3d7ee1e6af41a5b0d3e7">engine</a> eng(engine_kind, 0);</div></div><!-- fragment --><p> In addition to an engine, all primitives require a <a class="el" href="structdnnl_1_1stream.html">dnnl::stream</a> for the execution. The stream encapsulates an execution context and is tied to a particular engine.</p>
<p>The creation is pretty straightforward: </p><div class="fragment"><div class="line">    stream engine_stream(eng);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 In the simple cases, when a program works with one device only (e.g. only on CPU), an engine and a stream can be created once and used throughout the program. Some frameworks create singleton objects that hold oneDNN engine and stream and use them throughout the code. <br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="getting_started_cpp_sub2"></a>
Data preparation (code outside of oneDNN)</h2>
<p>Now that the preparation work is done, let's create some data to work with. We will create a 4D tensor in NHWC format, which is quite popular in many frameworks.</p>
<p>Note that even though we work with one image only, the image tensor is still 4D. The extra dimension (here N) corresponds to the batch, and, in case of a single image, is equal to 1. It is pretty typical to have the batch dimension even when working with a single image.</p>
<p>In oneDNN, all CNN primitives assume that tensors have the batch dimension, which is always the first logical dimension (see also <a class="el" href="dev_guide_conventions.html">Naming Conventions</a>).</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> N = 1, H = 13, W = 13, C = 3;</div><div class="line"></div><div class="line">    <span class="comment">// Compute physical strides for each dimension</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> stride_N = H * W * C;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> stride_H = W * C;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> stride_W = C;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> stride_C = 1;</div><div class="line"></div><div class="line">    <span class="comment">// An auxiliary function that maps logical index to the physical offset</span></div><div class="line">    <span class="keyword">auto</span> offset = [=](<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> c) {</div><div class="line">        <span class="keywordflow">return</span> n * stride_N + h * stride_H + w * stride_W + c * stride_C;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// The image size</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> image_size = N * H * W * C;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a buffer for the image</span></div><div class="line">    std::vector&lt;float&gt; image(image_size);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the image with some values</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; N; ++n)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h = 0; h &lt; H; ++h)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> w = 0; w &lt; W; ++w)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; C; ++c) {</div><div class="line">                    <span class="keywordtype">int</span> off = offset(</div><div class="line">                            n, h, w, c); <span class="comment">// Get the physical offset of a pixel</span></div><div class="line">                    image[off] = -std::cos(off / 10.f);</div><div class="line">                }</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h2><a class="anchor" id="getting_started_cpp_sub3"></a>
Wrapping data into a oneDNN memory object</h2>
<p>Now, having the image ready, let's wrap it in a <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a> object to be able to pass the data to oneDNN primitives.</p>
<p>Creating <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a> comprises two steps:</p><ol type="1">
<li>Initializing the <a class="el" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a> struct (also referred to as a memory descriptor), which only describes the tensor data and doesn't contain the data itself. Memory descriptors are used to create <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a> objects and to initialize primitive descriptors (shown later in the example).</li>
<li>Creating the <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a> object itself (also referred to as a memory object), based on the memory descriptor initialized in step 1, an engine, and, optionally, a handle to data. The memory object is used when a primitive is executed.</li>
</ol>
<p>Thanks to the <a href="https://en.cppreference.com/w/cpp/language/list_initialization">list initialization</a> introduced in C++11, it is possible to combine these two steps whenever a memory descriptor is not used anywhere else but in creating a <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a> object.</p>
<p>However, for the sake of demonstration, we will show both steps explicitly. <br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h3><a class="anchor" id="getting_started_cpp_sub31"></a>
Memory descriptor</h3>
<p>To initialize the <a class="el" href="structdnnl_1_1memory_1_1desc.html">dnnl::memory::desc</a>, we need to pass:</p><ol type="1">
<li>The tensor's dimensions, <b>the semantic order</b> of which is defined by <b>the primitive</b> that will use this memory (descriptor). Which leads to the following: <dl class="section warning"><dt>Warning</dt><dd>Memory descriptors and objects are not aware of any meaning of the data they describe or contain.</dd></dl>
</li>
<li>The data type for the tensor (<a class="el" href="structdnnl_1_1memory.html#a8e83474ec3a50e08e37af76c8c075dce">dnnl::memory::data_type</a>).</li>
<li>The memory format tag (<a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">dnnl::memory::format_tag</a>) that describes how the data is going to be laid out in the device's memory. The memory format is required for the primitive to correctly handle the data.</li>
</ol>
<p>The code: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> <a class="code" href="group__dnnl__api__primitives__common.html#gga94efdd650364f4d9776cfb9b711cbdc1a90a729e395453e1d9411ad416c796819">src_md</a> = memory::desc(</div><div class="line">            {N, C, H, W}, <span class="comment">// logical dims, the order is defined by a primitive</span></div><div class="line">            memory::data_type::f32, <span class="comment">// tensor&#39;s data type</span></div><div class="line">            memory::format_tag::nhwc <span class="comment">// memory format, NHWC in this case</span></div><div class="line">    );</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 The first thing to notice here is that we pass dimensions as <code>{N, C, H, W}</code> while it might seem more natural to pass <code>{N, H, W, C}</code>, which better corresponds to the user's code. This is because oneDNN CNN primitives like ReLU always expect tensors in the following form:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Spatial dim  </th><th class="markdownTableHeadLeft">Ten   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">0D  </td><td class="markdownTableBodyLeft">\(N \times C\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1D  </td><td class="markdownTableBodyLeft">\(N \times C \times W\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">2D  </td><td class="markdownTableBodyLeft">\(N \times C \times H \times W\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">3D  </td><td class="markdownTableBodyLeft">\(N \times C \times D \times H \times W\)   </td></tr>
</table>
<p>where:</p><ul>
<li>\(N\) is a batch dimension (discussed above),</li>
<li>\(C\) is channel (aka feature maps) dimension, and</li>
<li>\(D\), \(H\), and \(W\) are spatial dimensions.</li>
</ul>
<p>Now that the logical order of dimension is defined, we need to specify the memory format (the third parameter), which describes how logical indices map to the offset in memory. This is the place where the user's format NHWC comes into play. oneDNN has different <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">dnnl::memory::format_tag</a> values that cover the most popular memory formats like NCHW, NHWC, CHWN, and some others.</p>
<p>The memory descriptor for the image is called <code>src_md</code>. The <code>src</code> part comes from the fact that the image will be a source for the ReLU primitive (that is, we formulate memory names from the primitive perspective; hence we will use <code>dst</code> to name the output memory). The <code>md</code> is an initialism for Memory Descriptor. <br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 </p>
<h4><a class="anchor" id="getting_started_cpp_sub311"></a>
Alternative way to create a memory descriptor</h4>
<p>Before we continue with memory creation, let us show the alternative way to create the same memory descriptor: instead of using the <a class="el" href="structdnnl_1_1memory.html#a8e71077ed6a5f7fb7b3e6e1a5a2ecf3f">dnnl::memory::format_tag</a>, we can directly specify the strides of each tensor dimension: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> alt_src_md = memory::desc(</div><div class="line">            {N, C, H, W}, <span class="comment">// logical dims, the order is defined by a primitive</span></div><div class="line">            memory::data_type::f32, <span class="comment">// tensor&#39;s data type</span></div><div class="line">            {stride_N, stride_C, stride_H, stride_W} <span class="comment">// the strides</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// Sanity check: the memory descriptors should be the same</span></div><div class="line">    <span class="keywordflow">if</span> (src_md != alt_src_md)</div><div class="line">        <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;Memory descriptor initialization mismatch.&quot;</span>);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
<br />
<br />
 Just as before, the tensor's dimensions come in the <code>N, C, H, W</code> order as required by CNN primitives. To define the physical memory format, the strides are passed as the third parameter. Note that the order of the strides corresponds to the order of the tensor's dimensions. </p><dl class="section warning"><dt>Warning</dt><dd>Using the wrong order might lead to incorrect results or even a crash. <br />
<br />
<br />
<br />
<br />
<br />
 </dd></dl>
<h3><a class="anchor" id="getting_started_cpp_sub32"></a>
Creating a memory object</h3>
<p>Having a memory descriptor and an engine prepared, let's create input and output memory objects for a ReLU primitive. </p><div class="fragment"><div class="line">    <span class="comment">// src_mem contains a copy of image after write_to_dnnl_memory function</span></div><div class="line">    <span class="keyword">auto</span> src_mem = memory(src_md, eng);</div><div class="line">    write_to_dnnl_memory(image.data(), src_mem);</div><div class="line"></div><div class="line">    <span class="comment">// For dst_mem the library allocates buffer</span></div><div class="line">    <span class="keyword">auto</span> dst_mem = memory(src_md, eng);</div></div><!-- fragment --><p><br />
<br />
<br />
<br />
<br />
 We already have a memory buffer for the source memory object. We pass it to the <a class="el" href="structdnnl_1_1memory.html#a7463ff54b529ec2b5392230861212a09">dnnl::memory::memory(const desc &amp;, const engine &amp;, void *)</a> constructor that takes a buffer pointer as its last argument.</p>
<p>Let's use a constructor that instructs the library to allocate a memory buffer for the <code>dst_mem</code> for educational purposes.</p>
<p>The key difference between these two are:</p><ol type="1">
<li>The library will own the memory for <code>dst_mem</code> and will deallocate it when <code>dst_mem</code> is destroyed. That means the memory buffer can be used only while <code>dst_mem</code> is alive.</li>
<li>Library-allocated buffers have good alignment, which typically results in better performance.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Memory allocated outside of the library and passed to oneDNN should have good alignment for better performance.</dd></dl>
<p>In the subsequent section we will show how to get the buffer (pointer) from the <code>dst_mem</code> memory object. </p>
<h2><a class="anchor" id="getting_started_cpp_sub4"></a>
Creating a ReLU primitive</h2>
<p>Let's now create a ReLU primitive.</p>
<p>The library implements ReLU primitive as a particular algorithm of a more general <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitive, which applies a specified function to each and every element of the source tensor.</p>
<p>Just as in the case of <a class="el" href="structdnnl_1_1memory.html">dnnl::memory</a>, a user should always go through (at least) three creation steps (which however, can be sometimes combined thanks to C++11):</p><ol type="1">
<li>Initialize an operation descriptor (in this example, <a class="el" href="structdnnl_1_1eltwise__forward_1_1desc.html">dnnl::eltwise_forward::desc</a>), which defines the operation parameters.</li>
<li>Create an operation primitive descriptor (here <a class="el" href="structdnnl_1_1eltwise__forward_1_1primitive__desc.html">dnnl::eltwise_forward::primitive_desc</a>), which is a <b>lightweight</b> descriptor of the actual algorithm that <b>implements</b> the given operation. The user can query different characteristics of the chosen implementation such as memory consumptions and some others that will be covered in the next topic (<a class="el" href="memory_format_propagation_cpp.html">Memory Format Propagation</a>).</li>
<li>Create a primitive (here <a class="el" href="structdnnl_1_1eltwise__forward.html">dnnl::eltwise_forward</a>) that can be executed on memory objects to compute the operation.</li>
</ol>
<p>oneDNN separates steps 2 and 3 to enable the user to inspect details of a primitive implementation prior to creating the primitive. This may be expensive, because, for example, oneDNN generates the optimized computational code on the fly.</p>
<dl class="section note"><dt>Note</dt><dd>Primitive creation might be a very expensive operation, so consider creating primitive objects once and executing them multiple times.</dd></dl>
<p>The code: </p><div class="fragment"><div class="line">    <span class="comment">//  ReLU op descriptor (no engine- or implementation-specific information)</span></div><div class="line">    <span class="keyword">auto</span> relu_d = eltwise_forward::desc(</div><div class="line">            prop_kind::forward_inference, algorithm::eltwise_relu,</div><div class="line">            src_md, <span class="comment">// the memory descriptor for an operation to work on</span></div><div class="line">            0.f, <span class="comment">// alpha parameter means negative slope in case of ReLU</span></div><div class="line">            0.f <span class="comment">// beta parameter is ignored in case of ReLU</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// ReLU primitive descriptor, which corresponds to a particular</span></div><div class="line">    <span class="comment">// implementation in the library</span></div><div class="line">    <span class="keyword">auto</span> relu_pd</div><div class="line">            = eltwise_forward::primitive_desc(relu_d, <span class="comment">// an operation descriptor</span></div><div class="line">                    eng <span class="comment">// an engine the primitive will be created for</span></div><div class="line">            );</div><div class="line"></div><div class="line">    <span class="comment">// ReLU primitive</span></div><div class="line">    <span class="keyword">auto</span> relu = eltwise_forward(relu_pd); <span class="comment">// !!! this can take quite some time</span></div></div><!-- fragment --><p><br />
<br />
<br />
<br />
 A note about variable names. Similar to the <code>_md</code> suffix used for memory descriptor, we use <code>_d</code> for the operation descriptor names, <code>_pd</code> for the primitive descriptors, and no suffix for primitives themselves.</p>
<p>It is worth mentioning that we specified the exact tensor and its memory format when we were initializing the <code>relu_d</code>. That means <code>relu</code> primitive would perform computations with memory objects that correspond to this description. This is the one and only one way of creating non-compute-intensive primitives like <a class="el" href="dev_guide_eltwise.html">Eltwise</a>, <a class="el" href="dev_guide_batch_normalization.html">Batch Normalization</a>, and others.</p>
<p>Compute-intensive primitives (like <a class="el" href="dev_guide_convolution.html">Convolution</a>) have an ability to define the appropriate memory format on their own. This is one of the key features of the library and will be discussed in detail in the next topic: <a class="el" href="memory_format_propagation_cpp.html">Memory Format Propagation</a>. <br />
<br />
<br />
 </p>
<h2><a class="anchor" id="getting_started_cpp_sub5"></a>
Executing the ReLU primitive</h2>
<p>Finally, let's execute the primitive and wait for its completion.</p>
<p>The input and output memory objects are passed to the <code>execute()</code> method using a &lt;tag, memory&gt; map. Each tag specifies what kind of tensor each memory object represents. All <a class="el" href="dev_guide_eltwise.html">Eltwise</a> primitives require the map to have two elements: a source memory object (input) and a destination memory (output).</p>
<p>A primitive is executed in a stream (the first parameter of the <code>execute()</code> method). Depending on a stream kind, an execution might be blocking or non-blocking. This means that we need to call <a class="el" href="structdnnl_1_1stream.html#a59985fa8746436057cf51a820ef8929c">dnnl::stream::wait</a> before accessing the results.</p>
<div class="fragment"><div class="line">    <span class="comment">// Execute ReLU (out-of-place)</span></div><div class="line">    relu.execute(engine_stream, <span class="comment">// The execution stream</span></div><div class="line">            {</div><div class="line">                    <span class="comment">// A map with all inputs and outputs</span></div><div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, src_mem}, <span class="comment">// Source tag and memory obj</span></div><div class="line">                    {<a class="code" href="group__dnnl__api__primitives__common.html#ga3ca217e4a06d42a0ede3c018383c388f">DNNL_ARG_DST</a>, dst_mem}, <span class="comment">// Destination tag and memory obj</span></div><div class="line">            });</div><div class="line"></div><div class="line">    <span class="comment">// Wait the stream to complete the execution</span></div><div class="line">    engine_stream.wait();</div></div><!-- fragment --><p><br />
<br />
 The <a class="el" href="dev_guide_eltwise.html">Eltwise</a> is one of the primitives that support in-place operations, meaning that the source and destination memory can be the same. To perform in-place transformation, the user must pass the same memory object for both the <code>DNNL_ARG_SRC</code> and <code>DNNL_ARG_DST</code> tags: </p><div class="fragment"><div class="line">    <span class="comment">// Execute ReLU (in-place)</span></div><div class="line">    <span class="comment">// relu.execute(engine_stream,  {</span></div><div class="line">    <span class="comment">//          {DNNL_ARG_SRC, src_mem},</span></div><div class="line">    <span class="comment">//          {DNNL_ARG_DST, src_mem},</span></div><div class="line">    <span class="comment">//         });</span></div></div><!-- fragment --><p><br />
</p>
<h2><a class="anchor" id="getting_started_cpp_sub6"></a>
Obtaining the result and validation</h2>
<p>Now that we have the computed result, let's validate that it is actually correct. The result is stored in the <code>dst_mem</code> memory object. So we need to obtain the C++ pointer to a buffer with data via <a class="el" href="structdnnl_1_1memory.html#a8968c24c4a95255f68ab2a483769343d">dnnl::memory::get_data_handle()</a> and cast it to the proper data type as shown below.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="structdnnl_1_1memory.html#a8968c24c4a95255f68ab2a483769343d">dnnl::memory::get_data_handle()</a> returns a raw handle to the buffer, the type of which is engine specific. For the CPU engine the buffer is always a pointer to <code>void</code>, which can safely be used. However, for engines other than CPU the handle might be runtime-specific type, such as <code>cl_mem</code> in case of GPU/OpenCL.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">// Obtain a buffer for the `dst_mem` and cast it to `float *`.</span></div><div class="line">    <span class="comment">// This is safe since we created `dst_mem` as f32 tensor with known</span></div><div class="line">    <span class="comment">// memory format.</span></div><div class="line">    std::vector&lt;float&gt; relu_image(image_size);</div><div class="line">    read_from_dnnl_memory(relu_image.data(), dst_mem);</div><div class="line"></div><div class="line">    <span class="comment">// Check the results</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; N; ++n)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h = 0; h &lt; H; ++h)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> w = 0; w &lt; W; ++w)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; C; ++c) {</div><div class="line">                    <span class="keywordtype">int</span> off = offset(</div><div class="line">                            n, h, w, c); <span class="comment">// get the physical offset of a pixel</span></div><div class="line">                    <span class="keywordtype">float</span> expected = image[off] &lt; 0</div><div class="line">                            ? 0.f</div><div class="line">                            : image[off]; <span class="comment">// expected value</span></div><div class="line">                    <span class="keywordflow">if</span> (relu_image[off] != expected) {</div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;At index(&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; h</div><div class="line">                                  &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; w &lt;&lt; <span class="stringliteral">&quot;) expect &quot;</span> &lt;&lt; expected</div><div class="line">                                  &lt;&lt; <span class="stringliteral">&quot; but got &quot;</span> &lt;&lt; relu_image[off]</div><div class="line">                                  &lt;&lt; std::endl;</div><div class="line">                        <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;Accuracy check failed.&quot;</span>);</div><div class="line">                    }</div><div class="line">                }</div></div><!-- fragment --> <h1><a class="anchor" id="getting_started_cpp_main"></a>
main() function</h1>
<p>We now just call everything we prepared earlier.</p>
<p>Because we are using the oneDNN C++ API, we use exceptions to handle errors (see <a class="el" href="dev_guide_c_and_cpp_apis.html">API</a>). The oneDNN C++ API throws exceptions of type <a class="el" href="structdnnl_1_1error.html">dnnl::error</a>, which contains the error status (of type <a class="el" href="group__dnnl__api__utils.html#gad24f9ded06e34d3ee71e7fc4b408d57a">dnnl_status_t</a>) and a human-readable error message accessible through regular <code>what()</code> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">    <span class="keywordtype">int</span> exit_code = 0;</div><div class="line"></div><div class="line">    engine::kind engine_kind = parse_engine_kind(argc, argv);</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        getting_started_tutorial(engine_kind);</div><div class="line">    } <span class="keywordflow">catch</span> (<a class="code" href="structdnnl_1_1error.html">dnnl::error</a> &amp;e) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;oneDNN error caught: &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\tStatus: &quot;</span> &lt;&lt; dnnl_status2str(e.status) &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\tMessage: &quot;</span> &lt;&lt; e.<a class="code" href="structdnnl_1_1error.html#afcf188632b6264fba24f3300dabd9b65">what</a>() &lt;&lt; std::endl;</div><div class="line">        exit_code = 1;</div><div class="line">    } <span class="keywordflow">catch</span> (std::string &amp;e) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error in the example: &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        exit_code = 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Example &quot;</span> &lt;&lt; (exit_code ? <span class="stringliteral">&quot;failed&quot;</span> : <span class="stringliteral">&quot;passed&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; on &quot;</span></div><div class="line">              &lt;&lt; engine_kind2str_upper(engine_kind) &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> exit_code;</div><div class="line">}</div></div><!-- fragment --><p> <b></b></p>
<p>Upon compiling and run the example the output should be just:</p>
<div class="fragment"><div class="line">Example passed.</div></div><!-- fragment --><p>Users are encouraged to experiment with the code to familiarize themselves with the concepts. In particular, one of the changes that might be of interest is to spoil some of the library calls to check how error handling happens. For instance, if we replace</p>
<div class="fragment"><div class="line">relu.execute(engine_stream, {</div><div class="line">        {<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, src_mem},</div><div class="line">        {<a class="code" href="group__dnnl__api__primitives__common.html#ga3ca217e4a06d42a0ede3c018383c388f">DNNL_ARG_DST</a>, dst_mem},</div><div class="line">    });</div></div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">relu.execute(engine_stream, {</div><div class="line">        {<a class="code" href="group__dnnl__api__primitives__common.html#gac37ad67b48edeb9e742af0e50b70fe09">DNNL_ARG_SRC</a>, src_mem},</div><div class="line">        <span class="comment">// {DNNL_ARG_DST, dst_mem}, // Oops, forgot about this one</span></div><div class="line">    });</div></div><!-- fragment --><p>we should get the following output:</p>
<div class="fragment"><div class="line">oneDNN error caught:</div><div class="line">        Status: <a class="code" href="group__dnnl__api__service.html#gga7acc4d3516304ae68a1289551d8f2cdda242ac674d98ee2191f0bbf6de851d2d0">invalid_arguments</a></div><div class="line">        Message: could not execute a primitive</div><div class="line">Example failed.</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
    <script>
        $('#top').prependTo($('#side-nav'));
    </script>
    <div class="footer-wrapper">
        <hr>
        <ul class="footer-links">
            <li><a href="legal_information.html">Legal information</a></li>
        </ul>
    </div>
</div>